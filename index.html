<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PennyDash - Personal Budgeting</title>
  
  <!-- Favicon -->
  <link rel="icon" href="generated-icon.png" type="image/png">
  
  <!-- Google Fonts: Inter + DM Serif Display -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Tailwind CSS with DaisyUI -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
  
  <!-- Vue.js and Chart.js -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- Reports View Styles -->
  <style>
    .reports-container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    
    .loading-placeholder {
      height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
  
  <!-- Tailwind Config -->
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: '#7C3AED',
            'primary-focus': '#6D28D9',
            'primary-content': '#FFFFFF',
            secondary: '#FFD700',
            'secondary-focus': '#EAC700',
            'secondary-content': '#000000',
            accent: '#7C3AED',
            'accent-focus': '#6D28D9',
            'accent-content': '#FFFFFF',
            neutral: '#121212',
            'neutral-focus': '#222222',
            'neutral-content': '#FFFFFF',
            'base-100': '#000000',
            'base-200': '#121212',
            'base-300': '#222222',
            'base-content': '#FFFFFF',
            info: '#3ABFF8',
            success: '#36D399',
            warning: '#FBBD23',
            error: '#F87272'
          },
          animation: {
            'fade-in': 'fadeIn 0.4s ease-out forwards',
            'slide-in': 'slideIn 0.3s ease-out forwards'
          },
          keyframes: {
            fadeIn: {
              '0%': { opacity: 0, transform: 'translateY(12px)' },
              '100%': { opacity: 1, transform: 'translateY(0)' }
            },
            slideIn: {
              '0%': { opacity: 0, transform: 'translateX(-12px)' },
              '100%': { opacity: 1, transform: 'translateX(0)' }
            }
          }
        }
      },
      plugins: [],
      daisyui: {
        themes: [
          {
            pennydash: {
              "primary": "#7C3AED",
              "primary-focus": "#6D28D9",
              "primary-content": "#FFFFFF",
              "secondary": "#FFD700",
              "secondary-focus": "#EAC700",
              "secondary-content": "#000000",
              "accent": "#7C3AED",
              "accent-focus": "#6D28D9",
              "accent-content": "#FFFFFF",
              "neutral": "#121212",
              "neutral-focus": "#222222",
              "neutral-content": "#FFFFFF",
              "base-100": "#000000",
              "base-200": "#121212",
              "base-300": "#222222",
              "base-content": "#FFFFFF",
              "info": "#3ABFF8",
              "success": "#36D399",
              "warning": "#FBBD23",
              "error": "#F87272"
            }
          }
        ],
        darkTheme: "pennydash"
      }
    }
  </script>
  
  <style>
    :root {
      /* Color system based on Riverside app design */
      --primary: #7C3AED;
      --primary-hover: #6D28D9;
      --primary-light: rgba(124, 58, 237, 0.15);
      --primary-50: rgba(124, 58, 237, 0.05);
      --primary-100: rgba(124, 58, 237, 0.1);
      
      --accent: #7C3AED;
      --accent-hover: #6D28D9;
      --accent-light: rgba(124, 58, 237, 0.15);
      
      --secondary: #FFD700;
      --secondary-hover: #EAC700;
      --secondary-light: rgba(255, 215, 0, 0.2);
      
      --bg-dark: #000000;
      --bg-dark-secondary: #121212;
      --bg-card: #121212;
      --bg-input: #222222;
      --bg-muted: #222222;
      
      --text-primary: #FFFFFF;
      --text-secondary: #ABABAB;
      --text-disabled: #666666;
      
      --border-default: #222222;
      --border-hover: #333333;
      --border-focus: #7C3AED;
      
      --success: #36D399;
      --warning: #FFD700;
      --error: #F87272;
      
      --shadow-sm: 0 2px 10px rgba(0, 0, 0, 0.2);
      --shadow-md: 0 4px 15px rgba(0, 0, 0, 0.3);
      --shadow-lg: 0 8px 25px rgba(0, 0, 0, 0.4);
      
      --radius-btn: 8px;
      --radius-card: 12px;
      --radius-input: 8px;
      --radius-badge: 16px;
      
      /* Spacing system */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-8: 32px;
      --space-10: 40px;
      
      /* Transitions */
      --transition-fast: 150ms ease-out;
      --transition-normal: 200ms ease-out;
      
      /* Soft color variants */
      --soft-blue: rgba(63, 131, 248, 0.1);
      --soft-lavender: rgba(255, 255, 255, 0.8);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-primary);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    h1, h2, h3, h4, h5, h6 {
      font-weight: 600;
      color: var(--text-primary);
    }
    
    h1 {
      font-size: 28px;
      line-height: 1.4;
    }
    
    h2 {
      font-size: 22px;
      line-height: 1.4;
    }
    
    h3 {
      font-size: 18px;
      line-height: 1.4;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* Cards */
    .card {
      background-color: var(--bg-card);
      border-radius: var(--radius-card);
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-normal);
      border: none;
      padding: var(--space-6);
    }
    
    .card:hover {
      box-shadow: var(--shadow-md);
      filter: brightness(1.05);
    }
    
    .card-body {
      padding: 0;
    }
    
    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-btn);
      font-weight: 600;
      font-size: 14px;
      padding: 12px 24px;
      cursor: pointer;
      transition: all var(--transition-fast);
      white-space: nowrap;
      outline: none;
      border: none;
      height: 40px;
    }
    
    .btn-sm {
      padding: 8px 16px;
      height: 32px;
      font-size: 13px;
    }
    
    .btn-icon {
      margin-right: 8px;
    }
    
    .btn-primary {
      background-color: var(--primary);
      color: var(--text-primary);
    }
    
    .btn-primary:hover {
      filter: brightness(1.1);
      transform: scale(1.02);
    }
    
    .btn-primary:active {
      filter: brightness(0.95);
      transform: scale(1);
    }
    
    .btn-secondary {
      background-color: var(--bg-muted);
      color: var(--text-primary);
      border: none;
    }
    
    .btn-secondary:hover {
      filter: brightness(1.1);
      color: var(--text-primary);
    }
    
    .btn-accent {
      background-color: var(--accent);
      color: var(--text-primary);
    }
    
    .btn-accent:hover {
      filter: brightness(1.1);
      transform: scale(1.02);
    }
    
    .btn-ghost {
      background-color: transparent;
      color: var(--text-primary);
    }
    
    .btn-ghost:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    /* Upload Zone */
    .upload-zone {
      border: 2px dashed var(--border-hover);
      border-radius: var(--radius-card);
      background-color: var(--bg-muted);
      transition: all var(--transition-fast);
      padding: var(--space-6);
    }
    
    .upload-zone:hover, .upload-zone.active {
      border-color: var(--primary);
      background-color: rgba(124, 58, 237, 0.1);
      transform: scale(1.01);
    }
    
    /* Progress elements */
    .progress-bar {
      height: 8px;
      border-radius: 4px;
      background-color: var(--bg-muted);
      overflow: hidden;
    }
    
    .progress-bar-fill {
      height: 100%;
      background-color: var(--primary);
      transition: width 0.8s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    
    /* Navigation */
    .navbar {
      background-color: var(--bg-dark);
      border-bottom: 1px solid var(--border-default);
      padding: var(--space-4) 0;
    }
    
    .nav-item {
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-btn);
      transition: all var(--transition-fast);
      color: var(--text-secondary);
      font-weight: 500;
    }
    
    .nav-item:hover {
      color: var(--text-primary);
      background-color: var(--bg-muted);
    }
    
    .nav-item.active {
      background-color: var(--primary);
      color: var(--text-primary);
      font-weight: 600;
    }
    
    .menu-horizontal a {
      color: var(--text-secondary);
      font-weight: 500;
      transition: all var(--transition-fast);
    }
    
    .menu-horizontal a:hover {
      color: var(--text-primary);
    }
    
    .menu-horizontal a.active {
      color: var(--primary);
      font-weight: 600;
    }
    
    /* Step indicators */
    .step-circle {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    
    .step-circle.active {
      background-color: var(--primary);
      color: white;
      box-shadow: 0 3px 10px rgba(65, 46, 188, 0.3);
    }
    
    .step-circle.completed {
      background-color: var(--success);
      color: white;
    }
    
    .step-circle.inactive {
      background-color: var(--bg-muted);
      color: var(--text-muted);
    }
    
    .step-line {
      height: 2px;
      background-color: var(--bg-muted);
      position: relative;
    }
    
    .step-line::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background-color: var(--primary);
      transition: width 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    
    .step-line.half::after {
      width: 50%;
    }
    
    .step-line.complete::after {
      width: 100%;
    }
    
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-12px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .fade-in {
      animation: fadeIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    }
    
    .slide-in {
      animation: slideIn 0.3s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    }
    
    /* Misc styles */
    .badge {
      padding: 4px 12px;
      border-radius: var(--radius-badge);
      font-size: 12px;
      font-weight: 500;
      transition: all var(--transition-fast);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .badge-success {
      background-color: rgba(54, 211, 153, 0.15);
      color: var(--success);
    }
    
    .badge-primary {
      background-color: var(--primary-light);
      color: var(--text-primary);
    }
    
    .badge-warning {
      background-color: rgba(255, 215, 0, 0.15);
      color: var(--warning);
    }
    
    .badge-accent {
      background-color: var(--primary-light);
      color: var(--text-primary);
    }
    
    .badge-outline {
      background-color: transparent;
      border: 1px solid currentColor;
    }
    
    .badge-pro {
      background-color: var(--bg-dark);
      color: var(--secondary);
      border: 1px solid var(--secondary);
      font-weight: 600;
    }
    
    .icon-circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--soft-blue);
      color: var(--primary);
      transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    
    .icon-circle:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(37, 30, 90, 0.1);
    }
    
    .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: var(--secondary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }
    
    .avatar:hover {
      border-color: var(--secondary-hover);
      transform: scale(1.05);
      background-color: var(--secondary-hover);
    }
  </style>
  
  <!-- Transaction Enrichment Flow Styles -->
  <style>
    .upload-enrichment-modal {
      max-width: 1000px;
      width: calc(100% - 2rem);
      margin: 0 auto;
    }
    
    .transaction-batch {
      border-left: 3px solid #7C3AED;
      transition: all 0.3s ease;
    }
    
    .transaction-batch:hover {
      background-color: rgba(124, 58, 237, 0.05);
    }
    
    .batch-progress {
      height: 0.5rem;
      border-radius: 9999px;
      background: linear-gradient(to right, #7C3AED, #10b981);
    }
    
    .transaction-attribute-tag {
      background-color: rgba(124, 58, 237, 0.1);
      color: #7C3AED;
      border-radius: 9999px;
      padding: 0.25rem 0.75rem;
      display: inline-flex;
      align-items: center;
      font-size: 0.75rem;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .category-pill {
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .category-pill:hover {
      transform: translateY(-2px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    }
    
    .review-modal {
      max-width: 90%;
      width: 1100px;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .transaction-row {
      transition: background-color 0.2s ease;
    }
    
    .transaction-row:hover {
      background-color: rgba(124, 58, 237, 0.05);
    }
    }
    
    .confetti-animation {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
    }
    
    .transaction-table-compact th, .transaction-table-compact td {
      padding: 0.5rem;
      font-size: 0.875rem;
    }
    
    .attribute-selector {
      border: 1px solid rgba(124, 58, 237, 0.3);
      border-radius: 0.375rem;
      transition: all 0.2s ease;
    }
    
    .attribute-selector:focus-within {
      border-color: #7C3AED;
      box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.2);
    }
    
    .tag-animation {
      animation: tagSlideIn 0.3s ease-out forwards;
    }
    
    @keyframes tagSlideIn {
      0% { 
        opacity: 0;
        transform: translateY(8px);
      }
      100% { 
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>
<body data-theme="pennydash" class="min-h-screen bg-base-100 text-base-content">
  <div id="app">
    <div class="flex min-h-screen">
      <!-- Sidebar Navigation -->
      <div class="w-64 bg-base-300 border-r border-base-200 shrink-0 hidden md:block">
        <!-- App Logo -->
        <div class="py-6 px-5 flex items-center gap-3">
          <div class="btn btn-circle btn-ghost text-accent bg-base-200">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 18.75a60.07 60.07 0 0115.797 2.101c.727.198 1.453-.342 1.453-1.096V18.75M3.75 4.5v.75A.75.75 0 013 6h-.75m0 0v-.375c0-.621.504-1.125 1.125-1.125H20.25M2.25 6v9m18-10.5v.75c0 .414.336.75.75.75h.75m-1.5-1.5h.375c.621 0 1.125.504 1.125 1.125v9.75c0 .621-.504 1.125-1.125 1.125h-.375m1.5-1.5H21a.75.75 0 01-.75.75h-.75m0-1.5h.75a.75.75 0 01.75.75v.75m0 0H3.75m0 0h-.375a1.125 1.125 0 01-1.125-1.125V15m1.5 1.5v-.75A.75.75 0 003 15h-.75M15 10.5a3 3 0 11-6 0 3 3 0 016 0zm3 0h.008v.008H18V10.5zm-12 0h.008v.008H6V10.5z" />
            </svg>
          </div>
          <a class="font-serif text-xl font-semibold text-accent">PennyDash</a>
        </div>
        
        <!-- Sidebar Navigation Menu -->
        <nav class="pt-4">
          <ul class="menu menu-vertical px-4 gap-1">
            <li>
              <a @click="activeTab = 'home'" :class="activeTab === 'home' ? 'bg-primary/20 text-primary' : ''" class="flex items-center py-3 px-4 rounded-lg transition-all">
                <div class="w-7 h-7 flex items-center justify-center mr-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25" />
                  </svg>
                </div>
                Dashboard
              </a>
            </li>
            <li>
              <a @click="activeTab = 'transactions'" :class="activeTab === 'transactions' ? 'bg-primary/20 text-primary' : ''" class="flex items-center py-3 px-4 rounded-lg transition-all">
                <div class="w-7 h-7 flex items-center justify-center mr-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21L3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
                  </svg>
                </div>
                Transactions
              </a>
            </li>
            <li>
              <a @click="activeTab = 'reviewQueue'" :class="activeTab === 'reviewQueue' ? 'bg-primary/20 text-primary' : ''" class="flex items-center py-3 px-4 rounded-lg transition-all">
                <div class="w-7 h-7 flex items-center justify-center mr-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0118 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3l1.5 1.5 3-3.75" />
                  </svg>
                </div>
                Review Queue
              </a>
            </li>
            <li>
              <a @click="activeTab = 'categories'" :class="activeTab === 'categories' ? 'bg-primary/20 text-primary' : ''" class="flex items-center py-3 px-4 rounded-lg transition-all">
                <div class="w-7 h-7 flex items-center justify-center mr-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z" />
                  </svg>
                </div>
                Categories
              </a>
            </li>
            <li>
              <a @click="activeTab = 'reports'" :class="activeTab === 'reports' ? 'bg-primary/20 text-primary' : ''" class="flex items-center py-3 px-4 rounded-lg transition-all">
                <div class="w-7 h-7 flex items-center justify-center mr-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6a7.5 7.5 0 107.5 7.5h-7.5V6z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0013.5 3v7.5z" />
                  </svg>
                </div>
                Reports
              </a>
            </li>
            <li>
              <a @click="activeTab = 'settings'" :class="activeTab === 'settings' ? 'bg-primary/20 text-primary' : ''" class="flex items-center py-3 px-4 rounded-lg transition-all">
                <div class="w-7 h-7 flex items-center justify-center mr-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </svg>
                </div>
                Settings
              </a>
            </li>
          </ul>
        </nav>
      </div>
      
      <!-- Mobile Navigation Menu -->
      <div class="btm-nav z-50 bg-base-200 border-t border-base-300 md:hidden">
        <button @click="activeTab = 'home'" :class="activeTab === 'home' ? 'active text-primary' : ''">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25" />
          </svg>
          <span class="btm-nav-label text-xs">Home</span>
        </button>
        <button @click="activeTab = 'transactions'" :class="activeTab === 'transactions' ? 'active text-primary' : ''">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21L3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
          </svg>
          <span class="btm-nav-label text-xs">Transactions</span>
        </button>
        <button @click="activeTab = 'reports'" :class="activeTab === 'reports' ? 'active text-primary' : ''">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6a7.5 7.5 0 107.5 7.5h-7.5V6z" />
            <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0013.5 3v7.5z" />
          </svg>
          <span class="btm-nav-label text-xs">Reports</span>
        </button>
        <button @click="activeTab = 'more'" :class="activeTab === 'more' ? 'active text-primary' : ''">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
          </svg>
          <span class="btm-nav-label text-xs">More</span>
        </button>
      </div>
      
      <!-- Main Content Area -->
      <div class="flex-1 p-4 md:px-6 md:py-8 overflow-y-auto pb-20 md:pb-8">
        <!-- Dashboard View -->
        <div v-if="activeTab === 'home'" class="space-y-6">
          <h1 class="text-2xl font-bold mb-6">Dashboard</h1>
          
          <!-- Upload Transaction Card -->
          <div class="card bg-base-200 shadow-md transition-all hover:shadow-lg">
            <div class="p-6">
              <h2 class="text-xl font-semibold mb-4">Upload Transactions</h2>
              <p class="text-base-content/80 mb-4">
                Import your transactions from your bank or financial institution to get started.
              </p>
              
              <div 
                class="upload-zone text-center p-8 cursor-pointer"
                :class="{'active': isUploadActive}"
                @click="$refs.fileInput.click()"
                @dragover.prevent="setUploadActive(true)"
                @dragleave.prevent="setUploadActive(false)"
                @drop.prevent="handleFileDrop($event); setUploadActive(false);"
              >
                <input 
                  type="file" 
                  ref="fileInput" 
                  class="hidden" 
                  @change="handleFileUpload"
                  accept=".csv,.ofx,.qfx,.pdf,.xlsx,.xls,.xml"
                >
                <div class="flex flex-col items-center justify-center gap-3">
                  <div class="bg-primary/20 p-3 rounded-full">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                  </div>
                  <div>
                    <p class="font-medium text-base-content">Drag & drop files here or <span class="text-primary">browse</span></p>
                    <p class="text-sm text-base-content/70 mt-1">Supports CSV, OFX, QFX, PDF, and Excel files</p>
                  </div>
                </div>
              </div>
              
              <!-- Error Alert (only show when there's an upload error) -->
              <div v-if="state.errors.upload" class="mt-4 alert alert-error">
                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                <span>{{ state.errors.upload }}</span>
              </div>
              
              <!-- Success Alert (only show when there's a success message) -->
              <div v-if="state.successMessages.upload" class="mt-4 alert alert-success">
                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                <span>{{ state.successMessages.upload }}</span>
              </div>
              
              <!-- Upload Progress (only show when something is uploaded) -->
              <div v-if="uploadProgress > 0" class="mt-4">
                <div class="flex justify-between items-center mb-2">
                  <span class="text-sm font-medium">Upload Progress</span>
                  <span class="text-sm font-medium">{{uploadProgress}}%</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" :style="{width: uploadProgress + '%'}"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Action Buttons -->
          <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
            <div class="card bg-base-200 shadow text-center transition-all hover:bg-primary/10 cursor-pointer">
              <div class="p-4 py-6 flex flex-col items-center">
                <div class="bg-base-300 p-3 rounded-full mb-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
                  </svg>
                </div>
                <span class="font-medium">Upload</span>
              </div>
            </div>
            
            <div class="card bg-base-200 shadow text-center transition-all hover:bg-primary/10 cursor-pointer">
              <div class="p-4 py-6 flex flex-col items-center">
                <div class="bg-base-300 p-3 rounded-full mb-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z" />
                  </svg>
                </div>
                <span class="font-medium">Categorize</span>
              </div>
            </div>
            
            <div class="card bg-base-200 shadow text-center transition-all hover:bg-primary/10 cursor-pointer" @click="activeTab = 'reports'">
              <div class="p-4 py-6 flex flex-col items-center">
                <div class="bg-base-300 p-3 rounded-full mb-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6a7.5 7.5 0 107.5 7.5h-7.5V6z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0013.5 3v7.5z" />
                  </svg>
                </div>
                <span class="font-medium">Create Report</span>
              </div>
            </div>
            
            <div class="card bg-base-200 shadow text-center transition-all hover:bg-primary/10 cursor-pointer">
              <div class="p-4 py-6 flex flex-col items-center">
                <div class="bg-base-300 p-3 rounded-full mb-3">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v6m3-3H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <span class="font-medium">Add Category</span>
              </div>
            </div>
          </div>
          
          <!-- KPI Cards -->
          <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <!-- KPI 1: Spending vs Income -->
            <div class="card bg-base-200 shadow-md">
              <div class="p-5">
                <div class="flex items-center mb-3">
                  <div class="icon-circle bg-primary/20 text-primary mr-3">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m-3-2.818l.879.659c1.171.879 3.07.879 4.242 0 1.172-.879 1.172-2.303 0-3.182C13.536 12.219 12.768 12 12 12c-.725 0-1.45-.22-2.003-.659-1.106-.879-1.106-2.303 0-3.182s2.9-.879 4.006 0l.415.33M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                  </div>
                  <h3 class="text-lg font-medium">Spending vs Income</h3>
                </div>
                
                <div v-if="!hasData" class="animate-pulse space-y-3">
                  <div class="h-4 bg-base-300 rounded w-3/4"></div>
                  <div class="h-10 bg-base-300 rounded"></div>
                  <div class="h-4 bg-base-300 rounded w-1/2"></div>
                </div>
                
                <div v-else>
                  <div class="flex items-end justify-between">
                    <div>
                      <p class="text-sm text-base-content/70">Current Month</p>
                      <p class="text-2xl font-bold">{{ formatCurrency(state.incomeVsExpenses.net) }}</p>
                    </div>
                    <div class="text-right">
                      <span class="badge" :class="state.incomeVsExpenses.net >= 0 ? 'badge-success' : 'badge-error'">
                        {{ state.incomeVsExpenses.savingsRate.toFixed(0) }}%
                      </span>
                    </div>
                  </div>
                  
                  <div class="mt-4">
                    <div class="flex justify-between items-center mb-1">
                      <span class="text-xs text-base-content/70">Spending</span>
                      <span class="text-xs font-medium">
                        {{ state.incomeVsExpenses.income > 0 
                          ? ((state.incomeVsExpenses.expenses / state.incomeVsExpenses.income) * 100).toFixed(0) 
                          : 0 }}%
                      </span>
                    </div>
                    <div class="progress-bar">
                      <div class="progress-bar-fill" 
                        :style="{ 
                          width: state.incomeVsExpenses.income > 0 
                            ? ((state.incomeVsExpenses.expenses / state.incomeVsExpenses.income) * 100) + '%'
                            : '0%',
                          backgroundColor: 'var(--error)'
                        }">
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- KPI 2: Top Spending Categories -->
            <div class="card bg-base-200 shadow-md">
              <div class="p-5">
                <div class="flex items-center mb-3">
                  <div class="icon-circle bg-primary/20 text-primary mr-3">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z" />
                      <path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z" />
                    </svg>
                  </div>
                  <h3 class="text-lg font-medium">Top Categories</h3>
                </div>
                
                <div v-if="!hasData" class="animate-pulse space-y-3">
                  <div class="h-4 bg-base-300 rounded w-3/4"></div>
                  <div class="space-y-2">
                    <div class="h-5 bg-base-300 rounded"></div>
                    <div class="h-5 bg-base-300 rounded"></div>
                    <div class="h-5 bg-base-300 rounded"></div>
                  </div>
                </div>
                
                <div v-else class="space-y-3">
                  <!-- Using top merchants as a temporary proxy for categories until categorization is fully implemented -->
                  <div v-if="state.topMerchants.length === 0" class="text-center text-sm text-base-content/70">
                    No categories data available yet
                  </div>
                  
                  <div v-for="(merchant, index) in state.topMerchants.slice(0, 3)" :key="index" class="flex justify-between items-center">
                    <span class="text-sm">{{ merchant.merchant || 'Uncategorized' }}</span>
                    <span class="text-sm font-medium">{{ formatCurrency(merchant.total) }}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- KPI 3: Spending Over Time -->
            <div class="card bg-base-200 shadow-md">
              <div class="p-5">
                <div class="flex items-center mb-3">
                  <div class="icon-circle bg-primary/20 text-primary mr-3">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" />
                    </svg>
                  </div>
                  <h3 class="text-lg font-medium">Spending Trend</h3>
                </div>
                
                <div v-if="!hasData" class="animate-pulse space-y-3">
                  <div class="h-4 bg-base-300 rounded w-3/4"></div>
                  <div class="h-24 bg-base-300 rounded"></div>
                </div>
                
                <div v-else>
                  <div class="flex items-end justify-between mb-3">
                    <div>
                      <p class="text-sm text-base-content/70">Total Expenses</p>
                      <p class="text-sm font-medium" :class="state.incomeVsExpenses.net >= 0 ? 'text-success' : 'text-error'">
                        {{ state.incomeVsExpenses.expenses > 0 ? formatCurrency(state.incomeVsExpenses.expenses) : '$0' }}
                      </p>
                    </div>
                    <div class="text-right">
                      <span class="text-sm font-medium">
                        {{ state.categorizationStatus.total }} transactions
                      </span>
                    </div>
                  </div>
                  
                  <!-- Categorization progress bar -->
                  <div class="mt-4">
                    <div class="flex justify-between items-center mb-1">
                      <span class="text-xs text-base-content/70">Categorized</span>
                      <span class="text-xs font-medium">{{ state.categorizationStatus.percentage.toFixed(1) }}%</span>
                    </div>
                    <div class="progress-bar">
                      <div class="progress-bar-fill" 
                        :style="{ 
                          width: state.categorizationStatus.percentage + '%',
                          backgroundColor: 'var(--primary)'
                        }">
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- KPI 4: Remaining Budget -->
            <div class="card bg-base-200 shadow-md">
              <div class="p-5">
                <div class="flex items-center mb-3">
                  <div class="icon-circle bg-primary/20 text-primary mr-3">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 18.75a60.07 60.07 0 0115.797 2.101c.727.198 1.453-.342 1.453-1.096V18.75M3.75 4.5v.75A.75.75 0 013 6h-.75m0 0v-.375c0-.621.504-1.125 1.125-1.125H20.25M2.25 6v9m18-10.5v.75c0 .414.336.75.75.75h.75m-1.5-1.5h.375c.621 0 1.125.504 1.125 1.125v9.75c0 .621-.504 1.125-1.125 1.125h-.375m1.5-1.5H21a.75.75 0 01-.75.75h-.75m0-1.5h.75a.75.75 0 01.75.75v.75m0 0H3.75m0 0h-.375a1.125 1.125 0 01-1.125-1.125V15m1.5 1.5v-.75A.75.75 0 003 15h-.75M15 10.5a3 3 0 11-6 0 3 3 0 016 0zm3 0h.008v.008H18V10.5zm-12 0h.008v.008H6V10.5z" />
                    </svg>
                  </div>
                  <h3 class="text-lg font-medium">Budget Status</h3>
                </div>
                
                <div v-if="!hasData" class="animate-pulse space-y-3">
                  <div class="h-4 bg-base-300 rounded w-3/4"></div>
                  <div class="h-32 bg-base-300 rounded"></div>
                </div>
                
                <div v-else>
                  <div class="text-center mb-2">
                    <p class="text-sm text-base-content/70">Net Balance</p>
                    <p class="text-2xl font-bold">{{ formatCurrency(state.incomeVsExpenses.net) }}</p>
                    <p class="text-sm">
                      Income: {{ formatCurrency(state.incomeVsExpenses.income) }} | 
                      Expenses: {{ formatCurrency(state.incomeVsExpenses.expenses) }}
                    </p>
                  </div>
                  
                  <div class="mt-3 flex items-center justify-center">
                    <div class="radial-progress" 
                      :class="state.incomeVsExpenses.net >= 0 ? 'text-success' : 'text-error'"
                      :style="`--value:${state.incomeVsExpenses.savingsRate > 100 ? 100 : Math.max(0, state.incomeVsExpenses.savingsRate)}; --size:5rem;`">
                      {{ state.incomeVsExpenses.savingsRate.toFixed(0) }}%
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Recent Transactions -->
          <div class="card bg-base-200 shadow-md mt-6">
            <div class="p-5">
              <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-medium">Recent Transactions</h3>
                <button class="btn btn-sm btn-ghost" @click="activeTab = 'transactions'">View All</button>
              </div>
              
              <div v-if="!hasData || state.loading.transactions" class="animate-pulse space-y-4">
                <div class="h-12 bg-base-300 rounded"></div>
                <div class="h-12 bg-base-300 rounded"></div>
                <div class="h-12 bg-base-300 rounded"></div>
              </div>
              
              <div v-else-if="state.recentTransactions.length === 0" class="text-center py-6 text-base-content/70">
                No recent transactions found. Upload transactions to get started.
              </div>
              
              <div v-else class="overflow-x-auto">
                <table class="table table-zebra w-full">
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Description</th>
                      <th>Amount</th>
                      <th>Category</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="tx in state.recentTransactions.slice(0, 5)" :key="tx.id" class="hover">
                      <td>{{ formatDate(tx.date) }}</td>
                      <td>
                        <div>
                          <div class="font-medium">{{ tx.description }}</div>
                          <div class="text-sm opacity-70">{{ tx.merchant || 'Unknown' }}</div>
                        </div>
                      </td>
                      <td :class="tx.type === 'income' ? 'text-success' : 'text-error'">
                        {{ tx.type === 'income' ? '+' : '-' }} {{ formatCurrency(Math.abs(tx.amount)) }}
                      </td>
                      <td>
                        <div class="badge" :style="{ backgroundColor: getCategoryColor(tx.category?.id), color: 'white' }">
                          {{ tx.category?.name || 'Uncategorized' }}
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Transactions View -->
        <div v-if="activeTab === 'transactions'" class="transactions-container">
          <!-- Transactions Controls -->
          <div class="mb-6 flex flex-wrap gap-3 items-center justify-between">
            <h1 class="text-2xl font-bold">Transactions</h1>
            
            <!-- Quick Filters -->
            <div class="flex items-center space-x-2">
              <div class="form-control">
                <div class="input-group">
                  <div class="relative w-full">
                    <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-base-content/70" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                    </div>
                    <input 
                      type="text" 
                      v-model="transactionSearchQuery" 
                      placeholder="Search transactions..." 
                      class="input input-bordered w-full pl-10 focus:border-primary focus:ring-1 focus:ring-primary"
                      @input="filterTransactions"
                    />
                  </div>
                </div>
              </div>
              <div class="dropdown dropdown-end">
                <button class="btn btn-outline" @click="toggleFilterDropdown">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.568a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z" />
                  </svg>
                  Filters
                </button>
                <ul v-if="isFilterDropdownOpen" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-64 mt-1">
                  <li class="menu-title">Transaction Type</li>
                  <li><a @click.stop="setTransactionTypeFilter('all')" :class="{'font-bold text-primary': transactionTypeFilter === 'all'}">All</a></li>
                  <li><a @click.stop="setTransactionTypeFilter('income')" :class="{'font-bold text-primary': transactionTypeFilter === 'income'}">Income</a></li>
                  <li><a @click.stop="setTransactionTypeFilter('expense')" :class="{'font-bold text-primary': transactionTypeFilter === 'expense'}">Expenses</a></li>

                  <li class="menu-title pt-2">Date Range</li>
                  <li><a @click.stop="setTransactionDateFilter('all')" :class="{'font-bold text-primary': transactionDateFilter === 'all'}">All Time</a></li>
                  <li><a @click.stop="setTransactionDateFilter('thisMonth')" :class="{'font-bold text-primary': transactionDateFilter === 'thisMonth'}">This Month</a></li>
                  <li><a @click.stop="setTransactionDateFilter('last3Months')" :class="{'font-bold text-primary': transactionDateFilter === 'last3Months'}">Last 3 Months</a></li>
                  
                  <li class="menu-title pt-2">Category</li>
                  <li><a @click.stop="setCategoryFilter('all')" :class="{'font-bold text-primary': categoryFilter === 'all'}">All Categories</a></li>
                  <li><a @click.stop="setCategoryFilter('uncategorized')" :class="{'font-bold text-primary': categoryFilter === 'uncategorized'}">Uncategorized</a></li>
                  <li v-for="category in state.categories" :key="category.id">
                    <a @click.stop="setCategoryFilter(category.id)" :class="{'font-bold text-primary': categoryFilter === category.id}">
                      <span class="badge badge-sm mr-1" :style="{ backgroundColor: category.color, color: 'white' }"></span>
                      {{ category.name }}
                    </a>
                  </li>
                </ul>
              </div>
              <button class="btn btn-primary" @click="openBatchCategoryModal" :disabled="filteredTransactions.length === 0">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z" />
                </svg>
                Categorize
              </button>
            </div>
          </div>
          
          <!-- Transaction Stats Summary -->
          <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
            <div class="stats shadow bg-base-200">
              <div class="stat">
                <div class="stat-title">Total Transactions</div>
                <div class="stat-value">{{ filteredTransactions.length }}</div>
                <div class="stat-desc">From {{ state.transactions.length }} total records</div>
              </div>
            </div>
            
            <div class="stats shadow bg-base-200">
              <div class="stat">
                <div class="stat-title">Total Income</div>
                <div class="stat-value text-success">{{ formatCurrency(calculateTotalIncome(filteredTransactions)) }}</div>
                <div class="stat-desc">{{ calculateCountByType(filteredTransactions, 'income') }} income transactions</div>
              </div>
            </div>
            
            <div class="stats shadow bg-base-200">
              <div class="stat">
                <div class="stat-title">Total Expenses</div>
                <div class="stat-value text-error">{{ formatCurrency(calculateTotalExpenses(filteredTransactions)) }}</div>
                <div class="stat-desc">{{ calculateCountByType(filteredTransactions, 'expense') }} expense transactions</div>
              </div>
            </div>
          </div>
          
          <!-- Transactions Table -->
          <div class="overflow-x-auto bg-base-200 rounded-lg shadow">
            <table class="table table-zebra w-full">
              <!-- Table Header -->
              <thead>
                <tr>
                  <th class="w-12">
                    <label>
                      <input type="checkbox" class="checkbox" v-model="selectAllTransactions" @change="toggleSelectAll" />
                    </label>
                  </th>
                  <th @click="sortTransactions('date')" class="cursor-pointer">
                    Date
                    <span v-if="transactionSort.field === 'date'">
                      {{ transactionSort.direction === 'asc' ? '' : '' }}
                    </span>
                  </th>
                  <th @click="sortTransactions('description')" class="cursor-pointer">
                    Description
                    <span v-if="transactionSort.field === 'description'">
                      {{ transactionSort.direction === 'asc' ? '' : '' }}
                    </span>
                  </th>
                  <th @click="sortTransactions('amount')" class="cursor-pointer">
                    Amount
                    <span v-if="transactionSort.field === 'amount'">
                      {{ transactionSort.direction === 'asc' ? '' : '' }}
                    </span>
                  </th>
                  <th @click="sortTransactions('account')" class="cursor-pointer">
                    Account
                    <span v-if="transactionSort.field === 'account'">
                      {{ transactionSort.direction === 'asc' ? '' : '' }}
                    </span>
                  </th>
                  <th @click="sortTransactions('accountType')" class="cursor-pointer">
                    Account Type
                    <span v-if="transactionSort.field === 'accountType'">
                      {{ transactionSort.direction === 'asc' ? '' : '' }}
                    </span>
                  </th>
                  <th @click="sortTransactions('currency')" class="cursor-pointer">
                    Currency
                    <span v-if="transactionSort.field === 'currency'">
                      {{ transactionSort.direction === 'asc' ? '' : '' }}
                    </span>
                  </th>
                  <th>Category</th>
                  <th>Confidence</th>
                  <th>Actions</th>
                </tr>
              </thead>
              
              <!-- Table Body -->
              <tbody>
                <tr v-if="state.loading.transactions">
                  <td colspan="9" class="text-center py-8">
                    <div class="flex justify-center items-center">
                      <span class="loading loading-spinner loading-md mr-2"></span>
                      Loading transactions...
                    </div>
                  </td>
                </tr>
                
                <tr v-else-if="filteredTransactions.length === 0">
                  <td colspan="9" class="text-center py-8">
                    No transactions found. Adjust your filters or upload new transactions.
                  </td>
                </tr>
                
                <tr v-for="tx in paginatedTransactions" :key="tx.id" class="hover">
                  <td>
                    <label>
                      <input type="checkbox" class="checkbox" v-model="selectedTransactions" :value="tx.id" />
                    </label>
                  </td>
                  <td>{{ formatDate(tx.date) }}</td>
                  <td>
                    <div class="flex items-center space-x-3">
                      <div>
                        <div class="font-medium">{{ tx.description }}</div>
                        <div class="text-sm opacity-70">{{ tx.merchant || 'Unknown' }}</div>
                      </div>
                    </div>
                  </td>
                  <td :class="tx.type === 'income' ? 'text-success' : 'text-error'">
                    {{ tx.type === 'income' ? '+' : '-' }} {{ formatCurrency(Math.abs(tx.amount)) }}
                  </td>
                  <td>{{ tx.account || 'Not specified' }}</td>
                  <td>
                    <div class="badge badge-outline">
                      {{ formatAccountType(tx.accountType) }}
                    </div>
                  </td>
                  <td>{{ tx.currency || 'USD' }}</td>
                  <td>
                    <div class="badge" :style="{ backgroundColor: getCategoryColor(tx.categoryId), color: 'white' }">
                      {{ getCategoryName(tx.categoryId) }}
                    </div>
                  </td>
                  <td>
                    <span v-if="tx.suggestionConfidence !== undefined" class="badge badge-sm" :class="getConfidenceBadgeClass(tx.suggestionConfidence)">
                      {{ Math.round(tx.suggestionConfidence * 100) }}%
                    </span>
                    <span v-else class="badge badge-sm badge-neutral">N/A</span>
                  </td>
                  <td>
                    <div class="flex space-x-1">
                      <button class="btn btn-xs btn-ghost" @click="editTransaction(tx)">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
                        </svg>
                      </button>
                      <button class="btn btn-xs btn-ghost" @click="deleteTransaction(tx.id)">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
                        </svg>
                      </button>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <!-- Pagination Controls -->
          <div class="flex justify-between items-center mt-4">
            <div class="text-sm">
              Showing {{ paginationStart + 1 }} to {{ Math.min(paginationStart + paginationLimit, filteredTransactions.length) }} of {{ filteredTransactions.length }} transactions
            </div>
            <div class="join">
              <button 
                class="join-item btn btn-sm" 
                :disabled="paginationStart === 0"
                @click="previousPage"
              >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                </svg>
              </button>
              <button class="join-item btn btn-sm">Page {{ currentPage }}</button>
              <button 
                class="join-item btn btn-sm" 
                :disabled="paginationStart + paginationLimit >= filteredTransactions.length"
                @click="nextPage"
              >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                </svg>
              </button>
            </div>
          </div>
          
          <!-- Batch Actions -->
          <div v-if="selectedTransactions.length > 0" class="fixed bottom-0 left-0 right-0 bg-base-200 p-4 shadow-lg border-t border-base-300 flex items-center justify-between z-50">
            <div>
              <span class="font-medium">{{ selectedTransactions.length }} transactions selected</span>
            </div>
            <div class="space-x-2">
              <div class="join">
                <select class="select select-bordered join-item" v-model="batchCategoryId">
                  <option disabled value="">Select category</option>
                  <option v-for="category in state.categories" :key="category.id" :value="category.id">
                    {{ category.name }}
                  </option>
                </select>
                <button class="btn join-item btn-primary" @click="applyBatchCategory" :disabled="!batchCategoryId">
                  Apply Category
                </button>
              </div>
              <button class="btn btn-error" @click="deleteBatchTransactions">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
                </svg>
                Delete
              </button>
            </div>
          </div>
        </div>
        
        <!-- Categories View -->
        <div v-if="activeTab === 'categories'" class="space-y-6">
          <div class="flex justify-between items-center mb-6">
            <h1 class="text-2xl font-bold">Categories</h1>
            
            <button class="btn btn-primary" @click="openCategoryModal()">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
              </svg>
              Add Category
            </button>
          </div>
          
          <!-- Loading State -->
          <div v-if="state.loading.categories" class="flex justify-center my-8">
            <span class="loading loading-spinner loading-lg text-primary"></span>
          </div>
          
          <!-- Error State -->
          <div v-else-if="state.errors.categories" class="alert alert-error">
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            <span>{{ state.errors.categories }}</span>
          </div>
          
          <!-- Empty State -->
          <div v-else-if="state.categories.length === 0" class="text-center py-12 bg-base-200 rounded-lg">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-12 h-12 mx-auto text-base-content/50 mb-3">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z" />
            </svg>
            <h3 class="text-lg font-medium mb-2">No Categories Found</h3>
            <p class="text-base-content/70 mb-4">You haven't created any categories yet.</p>
            <button class="btn btn-primary" @click="openCategoryModal()">
              Add Your First Category
            </button>
          </div>
          
          <!-- Categories List -->
          <div v-else>
            <!-- Income Categories -->
            <div class="mb-8">
              <h2 class="text-xl font-semibold mb-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-success mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                </svg>
                Income Categories
              </h2>
              <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <div v-for="category in incomeCategories" :key="category.id" class="card bg-base-100 shadow-sm hover:shadow-md transition-all">
                  <div class="card-body p-4">
                    <div class="flex items-center justify-between">
                      <div class="flex items-center">
                        <div class="w-8 h-8 rounded-full mr-3 flex items-center justify-center text-white" :style="{ backgroundColor: category.color }">
                          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                          </svg>
                        </div>
                        <h3 class="font-medium">{{ category.name }}</h3>
                      </div>
                      <div class="dropdown dropdown-end">
                        <label tabindex="0" class="btn btn-ghost btn-xs">
                          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 12.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 18.75a.75.75 0 110-1.5.75.75 0 010 1.5z" />
                          </svg>
                        </label>
                        <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52">
                          <li><a @click="editCategory(category)">Edit</a></li>
                          <li v-if="!category.isDefault"><a @click="deleteCategory(category.id)" class="text-error">Delete</a></li>
                        </ul>
                      </div>
                    </div>
                    <div class="flex justify-between items-center mt-3 text-sm">
                      <span>{{ getCategoryTransactionCount(category.id) }} transactions</span>
                      <span class="font-medium text-success">{{ formatCurrency(getCategoryTotal(category.id)) }}</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Expense Categories -->
            <div>
              <h2 class="text-xl font-semibold mb-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-error mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 17h8m0 0v-8m0 8l-8-8-4 4-6-6" />
                </svg>
                Expense Categories
              </h2>
              <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <div v-for="category in expenseCategories" :key="category.id" class="card bg-base-100 shadow-sm hover:shadow-md transition-all">
                  <div class="card-body p-4">
                    <div class="flex items-center justify-between">
                      <div class="flex items-center">
                        <div class="w-8 h-8 rounded-full mr-3 flex items-center justify-center text-white" :style="{ backgroundColor: category.color }">
                          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4" />
                          </svg>
                        </div>
                        <h3 class="font-medium">{{ category.name }}</h3>
                      </div>
                      <div class="dropdown dropdown-end">
                        <label tabindex="0" class="btn btn-ghost btn-xs">
                          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 12.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 18.75a.75.75 0 110-1.5.75.75 0 010 1.5z" />
                          </svg>
                        </label>
                        <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-52">
                          <li><a @click="editCategory(category)">Edit</a></li>
                          <li v-if="!category.isDefault"><a @click="deleteCategory(category.id)" class="text-error">Delete</a></li>
                        </ul>
                      </div>
                    </div>
                    <div class="flex justify-between items-center mt-3 text-sm">
                      <span>{{ getCategoryTransactionCount(category.id) }} transactions</span>
                      <span class="font-medium text-error">{{ formatCurrency(getCategoryTotal(category.id)) }}</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Settings View -->
        <div v-if="activeTab === 'settings'" class="space-y-6">
          <h1 class="text-2xl font-bold mb-6">Settings</h1>
          
          <!-- Loading State -->
          <div v-if="state.loading.settings" class="flex justify-center my-8">
            <span class="loading loading-spinner loading-lg text-primary"></span>
          </div>
          
          <!-- Error State -->
          <div v-else-if="state.errors.settings" class="alert alert-error">
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            <span>{{ state.errors.settings }}</span>
          </div>
          
          <!-- Settings Form -->
          <div v-else-if="state.settings" class="card bg-base-100 shadow-md">
            <div class="card-body">
              <form @submit.prevent="saveSettings">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <!-- General Settings Section -->
                  <div class="space-y-4">
                    <h3 class="text-lg font-semibold">General Settings</h3>
                    
                    <!-- Currency -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text">Currency</span>
                      </label>
                      <select v-model="settingsForm.currency" class="select select-bordered w-full">
                        <option value="USD">USD - US Dollar</option>
                        <option value="EUR">EUR - Euro</option>
                        <option value="GBP">GBP - British Pound</option>
                        <option value="JPY">JPY - Japanese Yen</option>
                        <option value="CAD">CAD - Canadian Dollar</option>
                        <option value="AUD">AUD - Australian Dollar</option>
                      </select>
                    </div>
                    
                    <!-- Locale -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text">Locale</span>
                      </label>
                      <select v-model="settingsForm.locale" class="select select-bordered w-full">
                        <option value="en-US">English (US)</option>
                        <option value="en-GB">English (UK)</option>
                        <option value="es-ES">Spanish</option>
                        <option value="fr-FR">French</option>
                        <option value="de-DE">German</option>
                        <option value="ja-JP">Japanese</option>
                      </select>
                    </div>
                    
                    <!-- Date Format -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text">Date Format</span>
                      </label>
                      <select v-model="settingsForm.dateFormat" class="select select-bordered w-full">
                        <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                        <option value="DD/MM/YYYY">DD/MM/YYYY</option>
                        <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                      </select>
                    </div>
                    
                    <!-- Theme -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text">Theme</span>
                      </label>
                      <select v-model="settingsForm.theme" class="select select-bordered w-full">
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                      </select>
                    </div>
                  </div>
                  
                  <!-- Advanced Settings Section -->
                  <div class="space-y-4">
                    <h3 class="text-lg font-semibold">Advanced Settings</h3>
                    
                    <!-- Category Suggestion Confidence -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text">Category Suggestion Confidence Threshold</span>
                      </label>
                      <input 
                        type="range" 
                        min="0.5" 
                        max="0.9" 
                        step="0.05" 
                        v-model="settingsForm.categorySuggestionConfidence" 
                        class="range range-primary" 
                      />
                      <div class="flex justify-between text-xs px-2 mt-1">
                        <span>More Suggestions (50%)</span>
                        <span>More Accurate (90%)</span>
                      </div>
                      <div class="text-center mt-1">
                        {{ Math.round(settingsForm.categorySuggestionConfidence * 100) }}%
                      </div>
                    </div>
                    
                    <!-- Default View -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text">Default View</span>
                      </label>
                      <select v-model="settingsForm.defaultView" class="select select-bordered w-full">
                        <option value="dashboard">Dashboard</option>
                        <option value="transactions">Transactions</option>
                        <option value="reports">Reports</option>
                      </select>
                    </div>
                    
                    <!-- Budget Start Day -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text">Budget Start Day</span>
                      </label>
                      <select v-model="settingsForm.budgetStart" class="select select-bordered w-full">
                        <option v-for="day in 28" :key="day" :value="day">{{ day }}</option>
                      </select>
                      <label class="label">
                        <span class="label-text-alt">Day of month when your budget period starts</span>
                      </label>
                    </div>
                    
                    <!-- Notification Settings -->
                    <div class="form-control">
                      <label class="label">
                        <span class="label-text font-medium">Notifications</span>
                      </label>
                      <label class="label cursor-pointer justify-start gap-3">
                        <input type="checkbox" v-model="settingsForm.notifications.budgetWarnings" class="checkbox checkbox-primary" />
                        <span class="label-text">Budget warnings</span>
                      </label>
                      <label class="label cursor-pointer justify-start gap-3">
                        <input type="checkbox" v-model="settingsForm.notifications.weeklyReports" class="checkbox checkbox-primary" />
                        <span class="label-text">Weekly reports</span>
                      </label>
                      <label class="label cursor-pointer justify-start gap-3">
                        <input type="checkbox" v-model="settingsForm.notifications.emailAlerts" class="checkbox checkbox-primary" />
                        <span class="label-text">Email alerts</span>
                      </label>
                    </div>
                  </div>
                </div>
                
                <div class="form-control mt-6">
                  <button type="submit" class="btn btn-primary" :disabled="state.loading.saveSettings">
                    <span v-if="state.loading.saveSettings" class="loading loading-spinner loading-sm"></span>
                    Save Settings
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
        
        <!-- Reports View -->
        <div v-if="activeTab === 'reports'" class="reports-container">
          <!-- Report Controls -->
          <div class="mb-6 flex flex-wrap gap-3 items-center justify-between">
            <h1 class="text-2xl font-bold">Reports & Analytics</h1>
            
            <!-- Date Range Selector -->
            <div class="flex items-center">
              <div class="join">
                <button 
                  class="btn btn-sm join-item"
                  :class="{'btn-primary': selectedDateRange === 'month', 'btn-outline': selectedDateRange !== 'month'}"
                  @click="setDateRange('month')"
                >
                  This Month
                </button>
                <button 
                  class="btn btn-sm join-item"
                  :class="{'btn-primary': selectedDateRange === '3months', 'btn-outline': selectedDateRange !== '3months'}"
                  @click="setDateRange('3months')"
                >
                  3 Months
                </button>
                <button 
                  class="btn btn-sm join-item"
                  :class="{'btn-primary': selectedDateRange === '6months', 'btn-outline': selectedDateRange !== '6months'}"
                  @click="setDateRange('6months')"
                >
                  6 Months
                </button>
                <button 
                  class="btn btn-sm join-item"
                  :class="{'btn-primary': selectedDateRange === 'year', 'btn-outline': selectedDateRange !== 'year'}"
                  @click="setDateRange('year')"
                >
                  Year
                </button>
              </div>
            </div>
          </div>
          
          <!-- Chart Grid -->
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Monthly Spending by Category Chart -->
            <div class="card bg-base-200 shadow-md">
              <div class="card-body">
                <h2 class="card-title text-lg mb-3">Monthly Spending by Category</h2>
                <div class="chart-container">
                  <canvas id="monthlySpendingChart" height="300"></canvas>
                </div>
              </div>
            </div>
            
            <!-- Spending Trend Over Time Chart -->
            <div class="card bg-base-200 shadow-md">
              <div class="card-body">
                <h2 class="card-title text-lg mb-3">Spending Trend Over Time</h2>
                <div class="chart-container">
                  <canvas id="trendChart" height="300"></canvas>
                </div>
              </div>
            </div>
            
            <!-- Spending by Category Doughnut Chart -->
            <div class="card bg-base-200 shadow-md">
              <div class="card-body">
                <h2 class="card-title text-lg mb-3">Spending by Category (This Month)</h2>
                <div class="chart-container">
                  <canvas id="categoryChart" height="300"></canvas>
                </div>
              </div>
            </div>
            
            <!-- Income vs Expenses Stacked Chart -->
            <div class="card bg-base-200 shadow-md">
              <div class="card-body">
                <h2 class="card-title text-lg mb-3">Income vs Expenses by Month</h2>
                <div class="chart-container">
                  <canvas id="incomeExpensesChart" height="300"></canvas>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Summary Section -->
          <div class="mt-8 card bg-primary text-primary-content">
            <div class="card-body">
              <h2 class="card-title">Financial Summary</h2>
              <div class="mt-2 grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="bg-base-100/20 p-4 rounded-lg">
                  <h3 class="font-semibold text-lg">Average Monthly Spending</h3>
                  <p class="text-2xl font-bold">$2,780</p>
                  <p class="text-sm opacity-80">
                    +3.5% compared to previous period
                  </p>
                </div>
                
                <div class="bg-base-100/20 p-4 rounded-lg">
                  <h3 class="font-semibold text-lg">Largest Expense</h3>
                  <p class="text-2xl font-bold">Housing</p>
                  <p class="text-sm opacity-80">
                    $1,200 (35% of total)
                  </p>
                </div>
                
                <div class="bg-base-100/20 p-4 rounded-lg">
                  <h3 class="font-semibold text-lg">Monthly Savings</h3>
                  <p class="text-2xl font-bold">$750</p>
                  <p class="text-sm opacity-80">
                    20% of monthly income
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Category Modal -->
    <div class="modal" :class="{'modal-open': isCategoryModalOpen}">
      <div class="modal-box relative">
        <h3 class="font-bold text-lg mb-4">{{ editingCategoryId ? 'Edit' : 'Add' }} Category</h3>
        
        <form @submit.prevent="saveCategory">
          <!-- Category Name -->
          <div class="form-control mb-4">
            <label class="label">
              <span class="label-text">Name</span>
            </label>
            <input type="text" placeholder="Category name" class="input input-bordered w-full" v-model="categoryForm.name" required />
          </div>
          
          <!-- Category Type -->
          <div class="form-control mb-4">
            <label class="label">
              <span class="label-text">Type</span>
            </label>
            <div class="flex">
              <label class="label cursor-pointer">
                <input type="radio" class="radio radio-primary" value="income" v-model="categoryForm.type" />
                <span class="ml-2 label-text">Income</span>
              </label>
              <label class="label cursor-pointer ml-6">
                <input type="radio" class="radio radio-primary" value="expense" v-model="categoryForm.type" />
                <span class="ml-2 label-text">Expense</span>
              </label>
            </div>
          </div>
          
          <!-- Category Color -->
          <div class="form-control mb-4">
            <label class="label">
              <span class="label-text">Color</span>
            </label>
            <div class="flex flex-wrap gap-2">
              <div
                v-for="color in colorPalette"
                :key="color"
                class="w-8 h-8 rounded-full cursor-pointer border-2 transition-all"
                :class="{ 'border-primary': categoryForm.color === color, 'border-transparent': categoryForm.color !== color }"
                :style="{ backgroundColor: color }"
                @click="categoryForm.color = color"
              ></div>
            </div>
          </div>
          
          <!-- Category Description -->
          <div class="form-control mb-4">
            <label class="label">
              <span class="label-text">Description (Optional)</span>
            </label>
            <textarea placeholder="Enter a description for this category" class="textarea textarea-bordered w-full" v-model="categoryForm.description"></textarea>
          </div>
          
          <div class="modal-action">
            <button type="button" class="btn" @click="closeCategoryModal">Cancel</button>
            <button type="submit" class="btn btn-primary">Save</button>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Transaction Edit Modal -->
    <div class="modal" :class="{'modal-open': isTransactionModalOpen}">
      <div class="modal-box relative max-w-2xl">
        <h3 class="font-bold text-lg mb-4">{{ editingTransactionId ? 'Edit' : 'Add' }} Transaction</h3>
        
        <form @submit.prevent="saveTransaction">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="form-control">
              <label class="label">
                <span class="label-text">Date</span>
              </label>
              <input type="date" class="input input-bordered" v-model="transactionForm.date" required />
            </div>
            
            <div class="form-control">
              <label class="label">
                <span class="label-text">Amount</span>
              </label>
              <input type="number" step="0.01" class="input input-bordered" v-model.number="transactionForm.amount" required placeholder="0.00" />
            </div>
          </div>
          
          <div class="form-control mt-2">
            <label class="label">
              <span class="label-text">Description</span>
            </label>
            <input type="text" class="input input-bordered" v-model="transactionForm.description" required placeholder="Transaction description" />
          </div>
          
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
            <div class="form-control">
              <label class="label">
                <span class="label-text">Transaction Type</span>
              </label>
              <select class="select select-bordered w-full" v-model="transactionForm.type">
                <option value="income">Income</option>
                <option value="expense">Expense</option>
              </select>
            </div>
            
            <div class="form-control">
              <label class="label">
                <span class="label-text">Merchant (Optional)</span>
              </label>
              <input type="text" class="input input-bordered" v-model="transactionForm.merchant" placeholder="e.g. Amazon, Starbucks" />
            </div>
          </div>
          
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
            <div class="form-control">
              <label class="label">
                <span class="label-text">Account</span>
              </label>
              <input type="text" class="input input-bordered" v-model="transactionForm.account" placeholder="e.g. Chase Checking, Amex Platinum" />
            </div>
            
            <div class="form-control">
              <label class="label">
                <span class="label-text">Account Type</span>
              </label>
              <select class="select select-bordered w-full" v-model="transactionForm.accountType">
                <option value="bank">Bank Account</option>
                <option value="credit_card">Credit Card</option>
                <option value="investment">Investment</option>
                <option value="cash">Cash</option>
                <option value="wallet">Digital Wallet</option>
                <option value="other">Other</option>
              </select>
            </div>
          </div>
          
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
            <div class="form-control">
              <label class="label">
                <span class="label-text">Currency</span>
              </label>
              <input type="text" class="input input-bordered" v-model="transactionForm.currency" placeholder="USD" maxlength="3" />
            </div>
            
            <div class="form-control">
              <label class="label">
                <span class="label-text">Category</span>
              </label>
              <select class="select select-bordered w-full" v-model="transactionForm.categoryId">
                <option value="">Uncategorized</option>
                <optgroup label="Income Categories" v-if="getIncomeCategories(state.categories).length">
                  <option v-for="category in getIncomeCategories(state.categories)" :key="category.id" :value="category.id">
                    {{ category.name }}
                  </option>
                </optgroup>
                <optgroup label="Expense Categories" v-if="getExpenseCategories(state.categories).length">
                  <option v-for="category in getExpenseCategories(state.categories)" :key="category.id" :value="category.id">
                    {{ category.name }}
                  </option>
                </optgroup>
              </select>
            </div>
          </div>
          
          <div class="form-control mt-2">
            <label class="label">
              <span class="label-text">Tags (Comma separated)</span>
            </label>
            <input type="text" class="input input-bordered" v-model="transactionForm.tagsInput" placeholder="e.g. vacation, business, recurring" />
          </div>
          
          <div class="form-control mt-2">
            <label class="label">
              <span class="label-text">Notes (Optional)</span>
            </label>
            <textarea class="textarea textarea-bordered" v-model="transactionForm.notes" placeholder="Add notes about this transaction"></textarea>
          </div>
          
          <div class="modal-action">
            <button type="button" class="btn" @click="closeTransactionModal">Cancel</button>
            <button type="submit" class="btn btn-primary">Save</button>
          </div>
        </form>
      </div>
      <label class="modal-backdrop" @click="closeTransactionModal"></label>
    </div>
    
    <!-- Transaction Enrichment Modal -->
    <div class="modal" :class="{'modal-open': state.enrichment.showModal}">
      <div class="modal-box relative max-w-4xl">
        <h3 class="font-bold text-lg mb-4">Transaction Enrichment</h3>
        
        <!-- Progress Bar -->
        <div class="w-full mb-6">
          <div class="text-sm mb-1 flex justify-between">
            <span>Progress</span>
            <span>{{ Math.round(state.enrichment.progress) }}%</span>
          </div>
          <div class="w-full bg-base-200 rounded-full h-2.5">
            <div class="bg-primary h-2.5 rounded-full" :style="{width: state.enrichment.progress + '%'}"></div>
          </div>
        </div>
        
        <!-- Steps -->
        <div class="flex justify-center mb-8">
          <ul class="steps steps-horizontal w-full">
            <li class="step" :class="{'step-primary': state.enrichment.progress > 0}">Upload</li>
            <li class="step" :class="{'step-primary': state.enrichment.progress >= 20}">Account Setup</li>
            <li class="step" :class="{'step-primary': state.enrichment.progress >= 40}">Batching</li>
            <li class="step" :class="{'step-primary': state.enrichment.progress >= 70}">Enrichment</li>
            <li class="step" :class="{'step-primary': state.enrichment.progress === 100}">Complete</li>
          </ul>
        </div>
        
        <!-- Step Content -->
        <div v-if="state.loading.enrichment" class="py-8 text-center">
          <div class="loading loading-spinner loading-lg text-primary"></div>
          <p class="mt-2">Processing transactions...</p>
        </div>
        
        <div v-else-if="state.errors.enrichment && state.errors.enrichment.length > 0" class="alert alert-error mb-4">
          <div>
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current flex-shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            <span>{{ state.errors.enrichment }}</span>
          </div>
        </div>
        
        <div v-else>
          <!-- Account Setup Step -->
          <div v-if="state.enrichment.currentStep === 'accountSetup'" class="mb-4">
            <h4 class="font-semibold text-md mb-2">Account Information</h4>
            <p class="text-sm mb-4">Before we process your transactions, please provide some information about the account they belong to.</p>
            
            <div v-for="(file, index) in state.enrichment.uploadedFiles" :key="index" class="card bg-base-200 mb-4">
              <div class="card-body">
                <h5 class="card-title text-sm font-medium">File: {{ file.fileName }}</h5>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
                  <div class="form-control">
                    <label class="label">
                      <span class="label-text">Account Source</span>
                    </label>
                    <div>
                      <select 
                        class="select select-bordered w-full mb-2" 
                        v-model="file.accountSourceSelection"
                        @change="updateAccountSource(file)"
                      >
                        <option value="" disabled>Select or add account source</option>
                        <option value="RBC">RBC</option>
                        <option value="TD">TD</option>
                        <option value="BMO">BMO</option>
                        <option value="CIBC">CIBC</option>
                        <option value="Scotiabank">Scotiabank</option>
                        <option value="Amex">American Express</option>
                        <option value="Chase">Chase</option>
                        <option value="Tangerine">Tangerine</option>
                        <option value="other">Other (specify)</option>
                      </select>
                      <input 
                        v-if="file.accountSourceSelection === 'other'"
                        type="text" 
                        class="input input-bordered w-full" 
                        placeholder="Enter your account source"
                        v-model="file.accountSource"
                      />
                    </div>
                  </div>
                  <div class="form-control">
                    <label class="label">
                      <span class="label-text">Account Type</span>
                    </label>
                    <select class="select select-bordered w-full" v-model="file.accountType">
                      <option value="" disabled>Select account type</option>
                      <option value="bank">Debit Account / Checking</option>
                      <option value="credit_card">Credit Card</option>
                      <option value="investment">Investment</option>
                      <option value="wallet">Digital Wallet</option>
                      <option value="cash">Cash</option>
                      <option value="other">Other</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="flex justify-end mt-6">
              <button 
                class="btn btn-primary" 
                @click="processAccountSetup()"
                :disabled="!areAccountDetailsComplete()"
              >
                Continue to Review
              </button>
            </div>
          </div>
          
          <!-- Batching Step -->
          <div v-else-if="state.enrichment.currentStep === 'batching'" class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <h4 class="font-semibold text-md">Transaction Batches</h4>
              <button class="btn btn-sm btn-ghost" @click="forceRefreshBatches" title="Refresh batch data">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Refresh
              </button>
            </div>
            
            <p class="text-sm mb-4">We've organized your transactions into groups to make them easier to categorize and enrich.</p>
            
            <!-- Error message for batching issues -->
            <div v-if="state.errors.enrichment" class="alert alert-error mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
              <div>
                <span>{{ state.errors.enrichment }}</span>
              </div>
            </div>
            
            <!-- Success message -->
            <div v-if="state.successMessages.enrichment" class="alert alert-success mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
              <span>{{ state.successMessages.enrichment }}</span>
            </div>
            
            <!-- Empty state if no batches found -->
            <div v-if="!state.enrichment.transactionBatches || state.enrichment.transactionBatches.length === 0" class="alert alert-warning mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
              <div class="flex flex-col space-y-2">
                <span class="font-medium">No transaction batches found</span>
                <span class="text-sm">This might be due to a data processing issue or the server hasn't finished organizing your transactions yet.</span>
                <div class="flex items-center space-x-2 mt-2">
                  <button 
                    class="btn btn-sm btn-warning" 
                    @click="forceRefreshBatches" 
                    :disabled="state.loading.enrichment"
                  >
                    <svg v-if="state.loading.enrichment" class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Refresh Batches
                  </button>
                  <span v-if="state.enrichment.currentUploadId" class="text-xs opacity-70">Upload ID: {{ state.enrichment.currentUploadId }}</span>
                </div>
              </div>
            </div>
            
            <!-- Card-based batch display with sample transactions and category recommendations -->
            <div class="grid grid-cols-1 gap-4">
              <div v-for="(batch, index) in state.enrichment.transactionBatches" :key="batch.batchId" 
                   class="card bg-base-200 hover:shadow-md transition-shadow duration-300">
                <div class="card-body">
                  <div class="flex justify-between items-center">
                    <h5 class="card-title text-lg">
                      <span v-if="getBatchDescription(batch)">{{ getBatchDescription(batch) }}</span>
                      <span v-else>Batch {{ index + 1 }}</span>
                    </h5>
                    <span class="badge badge-lg" :class="batch.statistics?.netDirection === 'negative' ? 'badge-error' : 'badge-success'">
                      {{ batch.statistics?.netDirection === 'negative' ? '- ' : '+ ' }}{{ formatCurrency(batch.statistics?.netAmount || 0) }}
                    </span>
                  </div>
                  
                  <div class="flex flex-wrap gap-2 mb-2">
                    <div class="badge badge-outline">{{ batch.transactions?.length || batch.transactionCount || 0 }} transactions</div>
                    <div class="badge badge-outline">
                      <span v-if="batch.statistics?.dateRange?.from && batch.statistics?.dateRange?.to">
                        {{ formatDate(batch.statistics.dateRange.from) }} to {{ formatDate(batch.statistics.dateRange.to) }}
                      </span>
                      <span v-else>No date range</span>
                    </div>
                    <!-- Show type as badge -->
                    <div v-if="batch.transactions && batch.transactions.length > 0" 
                         class="badge" 
                         :class="batch.transactions[0].type === 'expense' ? 'badge-error' : 'badge-success'">
                      {{ batch.transactions[0].type === 'expense' ? 'Expense' : 'Income' }}
                    </div>
                  </div>
                  
                  <!-- Category recommendations based on batch content -->
                  <div class="mt-1 mb-3">
                    <p class="text-xs text-base-content text-opacity-60 mb-1">Suggested categories:</p>
                    <div class="flex flex-wrap gap-1">
                      <!-- Generate category pills dynamically based on batch content -->
                      <div v-for="(categoryId, i) in getSuggestedCategoriesForBatch(batch)" :key="i" 
                           class="badge badge-sm badge-primary cursor-pointer hover:opacity-80"
                           @click="quickCategorize(batch.batchId, categoryId)">
                        {{ getCategoryName(state.categories, categoryId) }}
                      </div>
                      
                      <!-- If no suggested categories, show placeholder -->
                      <div v-if="!getSuggestedCategoriesForBatch(batch).length" 
                           class="text-xs text-base-content text-opacity-40">
                        No suggestions available
                      </div>
                    </div>
                  </div>
                  
                  <!-- Sample transactions -->
                  <div class="overflow-x-auto mt-2">
                    <table class="table table-compact w-full">
                      <thead>
                        <tr>
                          <th>Date</th>
                          <th>Description</th>
                          <th>Amount</th>
                          <th>Confidence</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr v-for="transaction in getSampleTransactions(batch)" :key="transaction.id">
                          <td>{{ formatDate(transaction.date) }}</td>
                          <td class="max-w-xs truncate">{{ transaction.description }}</td>
                          <td :class="transaction.type === 'expense' ? 'text-error' : 'text-success'">
                            {{ transaction.type === 'expense' ? '- ' : '+ ' }}{{ formatCurrency(transaction.amount) }}
                          </td>
                          <td>
                            <div v-if="transaction.categoryConfidence" class="flex items-center">
                              <div class="badge badge-xs mr-1" 
                                   :class="getConfidenceBadgeClass(transaction.categoryConfidence)">
                                {{ (transaction.categoryConfidence * 100).toFixed(0) }}%
                              </div>
                              <div class="w-16 h-1.5 bg-base-300 rounded-full overflow-hidden">
                                <div class="h-full rounded-full" 
                                     :class="getConfidenceBadgeClass(transaction.categoryConfidence)"
                                     :style="`width: ${transaction.categoryConfidence * 100}%`">
                                </div>
                              </div>
                            </div>
                            <span v-else class="text-xs opacity-50">Unknown</span>
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  
                  <!-- Show count of remaining transactions if more than shown -->
                  <div v-if="batch.transactions?.length > 3" class="text-xs text-center text-base-content text-opacity-60 mt-1">
                    + {{ batch.transactions.length - 3 }} more transactions
                  </div>
                  
                  <div class="card-actions justify-end mt-4">
                    <!-- View all transactions button -->
                    <button 
                      class="btn btn-outline btn-sm"
                      @click="viewAllTransactions(batch.batchId)"
                    >
                      View All
                    </button>
                    <!-- Review transactions button -->
                    <button 
                      class="btn btn-primary"
                      @click="reviewBatch(batch.batchId)"
                    >
                      Review Transactions
                    </button>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="mt-4">
              <div class="stats shadow w-full">
                <div class="stat">
                  <div class="stat-title">Total Transactions</div>
                  <div class="stat-value">{{ state.enrichment.statistics?.totalTransactions || 0 }}</div>
                </div>
                <div class="stat">
                  <div class="stat-title">Total Amount</div>
                  <div class="stat-value" :class="state.enrichment.statistics?.netDirection === 'negative' ? 'text-error' : 'text-success'">
                    {{ state.enrichment.statistics?.netDirection === 'negative' ? '- ' : '+ ' }}{{ formatCurrency(state.enrichment.statistics?.netAmount || 0) }}
                  </div>
                </div>
                <div class="stat">
                  <div class="stat-title">Sources</div>
                  <div class="stat-value text-secondary">{{ state.enrichment.statistics?.sources?.length || 0 }}</div>
                  <div class="stat-desc">{{ state.enrichment.statistics?.sources?.join(', ') }}</div>
                </div>
              </div>
            </div>
            
            <div class="flex justify-end mt-6">
              <!-- Added error message display when button is disabled -->
              <div v-if="state.enrichment.transactionBatches.length === 0" class="mr-4 text-error">
                No batches available. If you see this for too long, refresh the page or try uploading again.
              </div>
              <button 
                class="btn btn-primary" 
                @click="startEnrichAllBatches()"
                :disabled="state.enrichment.transactionBatches.length === 0 || state.loading.enrichment"
              >
                <span v-if="state.loading.enrichment" class="loading loading-spinner loading-sm mr-2"></span>
                <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
                </svg>
                {{ state.loading.enrichment ? 'Processing...' : 'Enrich All Batches' }}
              </button>
            </div>
          </div>
          
          <!-- Enrichment Step (Tinder-style) -->
          <div v-else-if="state.enrichment.currentStep === 'enrichment'" class="mb-4">
            <h4 class="font-semibold text-md mb-2">Batch Review</h4>
            <p class="text-sm mb-4">Swipe through each batch to quickly review and categorize similar transactions.</p>
            
            <div v-if="state.enrichment.pendingBatches && state.enrichment.pendingBatches.length > 0 && state.enrichment.currentBatch">
              <!-- Progress indicator -->
              <div class="flex justify-between items-center mb-4">
                <div class="text-sm">
                  Batch {{ state.enrichment.currentBatchIndex + 1 }} of {{ state.enrichment.pendingBatches.length }}
                </div>
                <div class="flex-1 mx-4">
                  <progress 
                    class="progress progress-primary" 
                    :value="state.enrichment.currentBatchIndex + 1" 
                    :max="state.enrichment.pendingBatches.length">
                  </progress>
                </div>
                <div class="text-sm">
                  {{ Math.round(((state.enrichment.currentBatchIndex + 1) / state.enrichment.pendingBatches.length) * 100) }}%
                </div>
              </div>
              
              <!-- Card UI for current batch -->
              <div class="card bg-base-200 shadow-lg mb-6">
                <div class="card-body">
                  <div class="flex justify-between items-center">
                    <h5 class="card-title text-lg">
                      <span v-if="getBatchDescription(state.enrichment.currentBatch)">
                        {{ getBatchDescription(state.enrichment.currentBatch) }}
                      </span>
                      <span v-else>Transaction Batch</span>
                    </h5>
                    <span class="badge badge-lg" 
                      :class="state.enrichment.currentBatch.statistics?.netDirection === 'negative' ? 'badge-error' : 'badge-success'">
                      {{ state.enrichment.currentBatch.statistics?.netDirection === 'negative' ? '- ' : '+ ' }}
                      {{ formatCurrency(state.enrichment.currentBatch.statistics?.netAmount || 0) }}
                    </span>
                  </div>
                  
                  <!-- Sample transactions from this batch -->
                  <div class="overflow-x-auto mt-3 mb-4">
                    <table class="table table-zebra w-full">
                      <thead>
                        <tr>
                          <th>Date</th>
                          <th>Description</th>
                          <th>Amount</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr v-for="transaction in getSampleTransactions(state.enrichment.currentBatch, 5)" 
                            :key="transaction.id">
                          <td>{{ formatDate(transaction.date) }}</td>
                          <td>{{ transaction.description }}</td>
                          <td :class="transaction.type === 'expense' ? 'text-error' : 'text-success'">
                            {{ transaction.type === 'expense' ? '- ' : '+ ' }}{{ formatCurrency(transaction.amount) }}
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  
                  <!-- Loading indicator for AI suggestions -->
                  <div v-if="state.loading.suggestions" class="mb-4 flex justify-center">
                    <div class="flex flex-col items-center">
                      <span class="loading loading-spinner loading-md text-primary mb-2"></span>
                      <p class="text-sm text-base-content opacity-70">Generating AI-powered category suggestions...</p>
                    </div>
                  </div>
                  
                  <!-- Error message for suggestions -->
                  <div v-if="state.errors.suggestions" class="alert alert-error mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <span>{{ state.errors.suggestions }}</span>
                  </div>
                  
                  <!-- Suggested category based on AI with confidence score -->
                  <div v-if="state.enrichment.suggestedCategory && !state.loading.suggestions" class="mb-4">
                    <div class="flex items-center gap-2 mb-2">
                      <div class="badge badge-lg badge-primary">AI Suggested</div>
                      <h6 class="font-medium">{{ getCategoryName(state.categories, state.enrichment.suggestedCategory) }}</h6>
                      <!-- Confidence badge -->
                      <div class="badge badge-sm" 
                        :class="{
                          'badge-success': state.enrichment.suggestedCategoryConfidence >= 0.8,
                          'badge-warning': state.enrichment.suggestedCategoryConfidence >= 0.6 && state.enrichment.suggestedCategoryConfidence < 0.8,
                          'badge-error': state.enrichment.suggestedCategoryConfidence < 0.6
                        }">
                        {{ Math.round((state.enrichment.suggestedCategoryConfidence || 0) * 100) }}% confidence
                      </div>
                    </div>
                    
                    <!-- Confidence bar -->
                    <div class="w-full bg-base-200 rounded-full h-2 mb-3">
                      <div class="h-2 rounded-full"
                        :style="{
                          width: `${(state.enrichment.suggestedCategoryConfidence || 0) * 100}%`,
                          backgroundColor: getConfidenceColor(state.enrichment.suggestedCategoryConfidence || 0)
                        }">
                      </div>
                    </div>
                    
                    <!-- Alternative suggestions -->
                    <div v-if="state.enrichment.aiSuggestions?.topCategories && state.enrichment.aiSuggestions.topCategories.length > 1" 
                         class="mb-3 flex flex-wrap gap-2">
                      <span class="text-sm opacity-70">Alternatives:</span>
                      <div v-for="(altCategory, i) in state.enrichment.aiSuggestions.topCategories.slice(1, 4)" :key="i" 
                          class="badge badge-sm cursor-pointer hover:opacity-80"
                          :style="{ backgroundColor: getCategoryColor(state.categories, altCategory.categoryId) }"
                          @click="selectAlternativeCategory(altCategory.categoryId)">
                        {{ getCategoryName(state.categories, altCategory.categoryId) }}
                        ({{ Math.round(altCategory.avgConfidence * 100) }}%)
                      </div>
                    </div>
                    
                    <div class="flex justify-center space-x-3 mb-4">
                      <button 
                        class="btn btn-success btn-lg" 
                        @click="acceptSuggestedCategory()"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                        </svg>
                        Accept
                      </button>
                      <button 
                        class="btn btn-outline btn-lg" 
                        @click="rejectSuggestedCategory()"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                        Choose Another
                      </button>
                    </div>
                  </div>
                  
                  <!-- Category selection form (shown when rejecting suggestion) -->
                  <div v-if="state.enrichment.showCategorySelector" class="mb-4">
                    <div class="form-control mb-4">
                      <label class="label">
                        <span class="label-text">Select Category</span>
                      </label>
                      <select class="select select-bordered w-full" v-model="batchCategoryId">
                        <option value="" disabled>Select a category</option>
                        <optgroup label="Income Categories">
                          <option v-for="category in getIncomeCategories(state.categories)" :key="category.id" :value="category.id">
                            {{ category.name }}
                          </option>
                        </optgroup>
                        <optgroup label="Expense Categories">
                          <option v-for="category in getExpenseCategories(state.categories)" :key="category.id" :value="category.id">
                            {{ category.name }}
                          </option>
                        </optgroup>
                      </select>
                    </div>
                    
                    <div class="form-control mb-4">
                      <label class="label">
                        <span class="label-text">Tags (comma separated)</span>
                      </label>
                      <input type="text" class="input input-bordered w-full" placeholder="e.g. vacation, travel, important" v-model="batchTags" />
                    </div>
                    
                    <div class="form-control mb-4">
                      <label class="label">
                        <span class="label-text">Notes</span>
                      </label>
                      <textarea class="textarea textarea-bordered w-full" placeholder="Add notes for these transactions" v-model="batchNotes"></textarea>
                    </div>
                    
                    <div class="flex justify-center space-x-3">
                      <button 
                        class="btn btn-primary" 
                        @click="applyCustomCategory()"
                        :disabled="!batchCategoryId"
                      >
                        Apply Category
                      </button>
                      <button 
                        class="btn btn-outline" 
                        @click="state.enrichment.showCategorySelector = false; state.enrichment.suggestedCategory = null"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Navigation controls -->
              <div class="flex justify-between mt-6">
                <button class="btn" @click="previousBatch()">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                  </svg>
                  Previous Batch
                </button>
                
                <button class="btn" @click="state.enrichment.currentStep = 'batching'">
                  Cancel Review
                </button>
                
                <button class="btn btn-primary" @click="nextBatch()" v-if="!isLastBatch()">
                  Skip This Batch
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                  </svg>
                </button>
                
                <button class="btn btn-success" @click="finishBatchReview()" v-else>
                  Finish Review
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                  </svg>
                </button>
              </div>
            </div>
            
            <div v-else>
              <div class="alert alert-success mb-4">
                <div>
                  <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current flex-shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                  <span>All batches have been enriched!</span>
                </div>
              </div>
              
              <div class="flex justify-end mt-6">
                <button class="btn" @click="state.enrichment.currentStep = 'batching'">
                  Back to Batches
                </button>
                <button class="btn btn-primary ml-2" @click="completeUpload(state.enrichment.currentUploadId)">
                  Complete Import
                </button>
              </div>
            </div>
          </div>
          
          <!-- Complete Step with Animation and Continue button -->
          <div v-else-if="state.enrichment.currentStep === 'complete'" class="mb-4 text-center py-8">
            <div class="mb-6">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-20 w-20 text-success mx-auto animate-bounce" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            
            <h3 class="font-bold text-2xl mb-2">All Done!</h3>
            <p class="text-lg mb-6">Your transactions have been successfully imported and enriched.</p>
            
            <div class="stats shadow mx-auto mb-8">
              <div class="stat">
                <div class="stat-title">Transactions Imported</div>
                <div class="stat-value">{{ state.enrichment.statistics?.totalTransactions || 0 }}</div>
              </div>
              <div class="stat">
                <div class="stat-title">Total Amount</div>
                <div class="stat-value" :class="state.enrichment.statistics?.netDirection === 'negative' ? 'text-error' : 'text-success'">
                  {{ state.enrichment.statistics?.netDirection === 'negative' ? '- ' : '+ ' }}{{ formatCurrency(state.enrichment.statistics?.netAmount || 0) }}
                </div>
              </div>
              <div class="stat">
                <div class="stat-title">Files Processed</div>
                <div class="stat-value">{{ state.enrichment.uploadedFiles?.length || 1 }}</div>
              </div>
            </div>
            
            <div class="flex justify-center gap-4">
              <button class="btn btn-outline" @click="closeEnrichmentModal">
                Close
              </button>
              <button class="btn btn-primary btn-lg" @click="continueToTransactions()">
                Continue to Transactions
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
              </button>
            </div>
          </div>
        </div>
        
        <div class="modal-action">
          <button type="button" class="btn" @click="closeEnrichmentModal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Transaction Review Modal -->
  <div class="modal" :class="{'modal-open': state.reviewModal.isOpen}">
    <div class="modal-box review-modal">
      <h3 class="font-bold text-xl mb-2">
        {{ state.reviewModal.title || 'Transaction Review' }}
      </h3>
      <p class="text-sm text-base-content/70 mb-4">
        Review and categorize transactions in this batch. Select multiple to apply the same category.
      </p>
      
      <div v-if="state.reviewModal.isLoading" class="py-10 text-center">
        <span class="loading loading-spinner loading-lg text-primary"></span>
        <p class="mt-4">Loading transactions...</p>
      </div>
      
      <div v-else-if="state.reviewModal.error" class="alert alert-error mb-4">
        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
        <span>{{ state.reviewModal.error }}</span>
      </div>
      
      <div v-else>
        <!-- Actions toolbar -->
        <div class="flex flex-wrap justify-between items-center mb-4 bg-base-200 p-2 rounded-lg">
          <div class="flex items-center space-x-2">
            <div class="form-control">
              <label class="cursor-pointer label">
                <input type="checkbox" v-model="state.reviewModal.selectAll" class="checkbox checkbox-sm checkbox-primary" @change="toggleSelectAllTransactions" />
                <span class="label-text ml-2">Select All</span>
              </label>
            </div>
            
            <span v-if="state.reviewModal.selectedIds.length > 0" class="text-sm font-medium">
              {{ state.reviewModal.selectedIds.length }} selected
            </span>
          </div>
          
          <div class="flex items-center space-x-2">
            <div v-if="state.reviewModal.selectedIds.length > 0" class="flex items-center">
              <select class="select select-bordered select-sm" v-model="state.reviewModal.batchCategoryId">
                <option value="" disabled>Select category</option>
                <optgroup label="Income Categories">
                  <option v-for="category in getIncomeCategories(state.categories)" :key="category.id" :value="category.id">
                    {{ category.name }}
                  </option>
                </optgroup>
                <optgroup label="Expense Categories">
                  <option v-for="category in getExpenseCategories(state.categories)" :key="category.id" :value="category.id">
                    {{ category.name }}
                  </option>
                </optgroup>
              </select>
              
              <button 
                class="btn btn-primary btn-sm ml-2" 
                :disabled="!state.reviewModal.batchCategoryId" 
                @click="reviewApplyCategory"
              >
                Apply to Selected
              </button>
            </div>
          </div>
        </div>
        
        <!-- Suggested categories for this batch -->
        <div class="mb-4">
          <p class="text-xs text-base-content/70 mb-1">Suggested categories:</p>
          <div class="flex flex-wrap gap-2">
            <div 
              v-for="category in state.reviewModal.suggestedCategories" 
              :key="category.id"
              class="badge badge-primary badge-lg cursor-pointer"
              @click="quickApplyCategory(category.id)"
            >
              {{ category.name }}
            </div>
            <div v-if="!state.reviewModal.suggestedCategories.length" class="text-sm text-base-content/50">
              No suggestions available
            </div>
          </div>
        </div>
        
        <!-- Transaction table -->
        <div class="overflow-x-auto">
          <table class="table table-compact w-full">
            <thead>
              <tr>
                <th></th>
                <th>Date</th>
                <th>Description</th>
                <th>Category</th>
                <th>Amount</th>
                <th>Confidence</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="transaction in state.reviewModal.transactions" :key="transaction.id" class="transaction-row">
                <td>
                  <input 
                    type="checkbox" 
                    :checked="state.reviewModal.selectedIds.includes(transaction.id)"
                    @change="toggleSelection(transaction.id)"
                    class="checkbox checkbox-sm checkbox-primary"
                  />
                </td>
                <td>{{ formatDate(transaction.date) }}</td>
                <td class="max-w-xs truncate" :title="transaction.description">{{ transaction.description }}</td>
                <td>
                  <div v-if="transaction.categoryId" class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full" :style="{ backgroundColor: getCategoryColor(state.categories, transaction.categoryId) }"></div>
                    <span>{{ getCategoryName(state.categories, transaction.categoryId) }}</span>
                  </div>
                  <span v-else class="text-base-content/50">Uncategorized</span>
                </td>
                <td :class="transaction.type === 'expense' ? 'text-error' : 'text-success'">
                  {{ transaction.type === 'expense' ? '- ' : '+ ' }}{{ formatCurrency(transaction.amount) }}
                </td>
                <td>
                  <span v-if="transaction.suggestionConfidence !== undefined" class="badge badge-sm" :class="getConfidenceBadgeClass(transaction.suggestionConfidence)">
                    {{ Math.round(transaction.suggestionConfidence * 100) }}%
                  </span>
                  <span v-else class="badge badge-sm badge-neutral">N/A</span>
                </td>
                <td>
                  <div class="flex items-center gap-1">
                    <select 
                      class="select select-bordered select-xs"
                      v-model="transaction.categoryId"
                      @change="updateTransactionCategory(transaction.id, transaction.categoryId)"
                    >
                      <option value="" disabled>Select</option>
                      <optgroup label="Income">
                        <option v-for="category in getIncomeCategories(state.categories)" :key="category.id" :value="category.id">
                          {{ category.name }}
                        </option>
                      </optgroup>
                      <optgroup label="Expense">
                        <option v-for="category in getExpenseCategories(state.categories)" :key="category.id" :value="category.id">
                          {{ category.name }}
                        </option>
                      </optgroup>
                    </select>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      
      <div class="modal-action">
        <button class="btn btn-outline" @click="closeReviewModal">Cancel</button>
        <button class="btn btn-primary" @click="finishReview">Done</button>
      </div>
    </div>
  </div>
  
  <script>
    // API Service Functions
    const api = {
      // Base API URLs
      baseUrl: '/api',
      
      // Generic request handler
      async request(endpoint, method = 'GET', data = null, extraOptions = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const options = {
          method,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          ...extraOptions // Include any additional options like signal for AbortController
        };
        
        if (data && (method === 'POST' || method === 'PUT')) {
          options.body = JSON.stringify(data);
        }
        
        try {
          const response = await fetch(url, options);
          
          if (!response.ok) {
            throw new Error(`API error: ${response.status} ${response.statusText}`);
          }
          
          // For 204 No Content responses (like from DELETE), return an empty object
          if (response.status === 204) {
            return {};
          }
          
          return await response.json();
        } catch (error) {
          console.error('API request failed:', error);
          throw error;
        }
      },
      
      // Transactions API
      transactions: {
        async getAll() {
          return api.request('/transactions');
        },
        
        async getById(id) {
          return api.request(`/transactions/${id}`);
        },
        
        async create(transaction) {
          return api.request('/transactions', 'POST', transaction);
        },
        
        async update(id, transaction) {
          return api.request(`/transactions/${id}`, 'PUT', transaction);
        },
        
        async delete(id) {
          return api.request(`/transactions/${id}`, 'DELETE');
        },
        
        async batchUpdateCategory(transactionIds, categoryId) {
          return api.request('/transactions/batch-categorize', 'POST', { 
            transactionIds, 
            categoryId 
          });
        },
        
        // Alias for batchUpdateCategory for better naming consistency
        async updateCategory(transactionIds, categoryId) {
          return this.batchUpdateCategory(transactionIds, categoryId);
        },
        
        async uploadFile(formData) {
          const url = `${api.baseUrl}/transactions/upload`;
          
          try {
            const response = await fetch(url, {
              method: 'POST',
              body: formData // No Content-Type header for multipart/form-data
            });
            
            if (!response.ok) {
              throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
            }
            
            return await response.json();
          } catch (error) {
            console.error('File upload failed:', error);
            throw error;
          }
        },
        
        // Get batches for an upload
        async getUploadedBatches(uploadId, options = {}) {
          return api.request(`/transactions/uploads/${uploadId}/batches`, 'GET', null, options);
        },
        
        // Update file transactions with account info 
        async updateFileTransactions(fileId, accountInfo) {
          return api.request(`/transactions/uploads/${fileId}/account-info`, 'PUT', accountInfo);
        },
        
        // Update account info for files in an upload
        async updateAccountInfo(uploadId, fileAccountInfoArray) {
          return api.request(`/transactions/uploads/${uploadId}/account-info`, 'PUT', fileAccountInfoArray);
        },
        
        // Enrich a batch of transactions
        async batchEnrich(batchId, enrichData) {
          return api.request(`/transactions/batches/${batchId}/enrich`, 'PUT', enrichData);
        },
        
        // Complete a batch
        async completeBatch(batchId) {
          return api.request(`/transactions/batches/${batchId}/complete`, 'POST');
        },
        
        // Complete an upload
        async completeUpload(uploadId) {
          return api.request(`/transactions/uploads/${uploadId}/complete`, 'POST');
        }
      },
      
      // Categories API
      categories: {
        async getAll() {
          return api.request('/categories');
        },
        
        async getById(id) {
          return api.request(`/categories/${id}`);
        },
        
        async create(category) {
          return api.request('/categories', 'POST', category);
        },
        
        async update(id, category) {
          return api.request(`/categories/${id}`, 'PUT', category);
        },
        
        async delete(id) {
          return api.request(`/categories/${id}`, 'DELETE');
        }
      },
      
      // Reports API
      reports: {
        async getDashboard() {
          return api.request('/reports/dashboard');
        },
        
        async getCategorySummary(timeframe = 'month') {
          return api.request(`/reports/category-summary?timeframe=${timeframe}`);
        },
        
        async getSpendingTrend(timeframe = '6months') {
          return api.request(`/reports/spending-trend?timeframe=${timeframe}`);
        },
        
        async getMonthlyFinances(months = 6) {
          return api.request(`/reports/monthly-finances?months=${months}`);
        },
        
        async getBudgetStatus() {
          return api.request('/reports/budget-status');
        }
      },
      
      // Settings API
      settings: {
        async get() {
          return api.request('/settings');
        },
        
        async update(settings) {
          return api.request('/settings', 'PUT', settings);
        }
      }
    };

    // Create Vue App
    const { createApp, ref, reactive, computed, onMounted, watch } = Vue;
    
    createApp({
      setup() {
        // State management
        const state = reactive({
          transactions: [],
          categories: [],
          reportData: {
            categorySummary: [],
            spendingTrend: [],
            monthlyFinances: []
          },
          // New dashboard-specific state
          dashboardData: null,
          incomeVsExpenses: { income: 0, expenses: 0, net: 0, savingsRate: 0 },
          categorizationStatus: { total: 0, categorized: 0, uncategorized: 0, percentage: 0 },
          topMerchants: [],
          recentTransactions: [],
          budgetStatus: null,
          settings: null,
          loading: {
            transactions: false,
            categories: false,
            reports: false,
            upload: false,
            saveSettings: false,
            enrichment: false,
            suggestions: false
          },
          // Properly initialize messages as null to prevent flash on load
          // Using null instead of empty strings for better conditional rendering
          successMessages: {
            upload: null,
            enrichment: null
          },
          errors: {
            transactions: null,
            categories: null,
            reports: null,
            settings: null,
            upload: null,
            enrichment: null,
            suggestions: null
          },
          // Enrichment flow state
          enrichment: {
            showModal: false,
            currentUploadId: null,
            transactionBatches: [], // All batches for the current upload
            processedBatches: [], // Batch IDs that have been processed
            pendingBatches: [], // Batch IDs that need to be processed
            currentStep: 'accountSetup', // 'accountSetup', 'batching', 'enrichment', 'complete'
            progress: 0,
            statistics: {
              totalTransactions: 0,
              netAmount: 0,
              sources: []
            },
            uploadedFiles: [], // Files with account info (source and type)
            currentBatch: null, // The batch currently being viewed in the UI
            currentBatchIndex: 0, // Index of the current batch
            showCategorySelector: false,
            suggestedCategory: null,
            suggestedCategoryConfidence: 0,
            aiSuggestions: {
              topCategories: [], // Array of objects with categoryId and confidence
              reasoning: null, // AI's reasoning for the suggestion
              source: null // Source of the suggestion ('openai' or 'bayes')
            },
            debugInfo: { // For diagnosis and debugging
              lastApiRequest: null,
              lastApiResponse: null,
              fetchTime: null,
              batchCount: 0,
              networkErrors: 0,
              retryCount: 0
            }
          },
          
          // Transaction Review Modal state
          reviewModal: {
            isOpen: false,
            title: '',
            batchId: null,
            transactions: [],
            selectedIds: [],
            batchCategoryId: '',
            isLoading: false,
            error: null,
            selectAll: false,
            suggestedCategories: []
          }
        });
        
        const hasData = ref(false);
        const isUploadActive = ref(false);
        const uploadProgress = ref(0);
        const activeTab = ref('home');
        const selectedDateRange = ref('month');
        
        // Transaction filtering and pagination
        const transactionSearchQuery = ref('');
        const selectedTransactions = ref([]);
        const selectAllTransactions = ref(false);
        const transactionTypeFilter = ref('all'); // all, income, expense
        const transactionDateFilter = ref('all'); // all, thisMonth, last3Months, custom
        const categoryFilter = ref('all'); // all, uncategorized, or category ID
        const paginationStart = ref(0);
        const paginationLimit = ref(20);
        const transactionSort = reactive({
          field: 'date',
          direction: 'desc'
        });
        const isFilterDropdownOpen = ref(false);
        
        // Batch actions
        const batchCategoryId = ref('');
        const batchTags = ref('');
        const batchNotes = ref('');
        const isBatchCategoryModalOpen = ref(false);
        
        // Category management
        const isCategoryModalOpen = ref(false);
        const editingCategoryId = ref(null);
        const categoryForm = reactive({
          name: '',
          type: 'expense',
          color: '#6366F1', // Default color (indigo)
          description: ''
        });
        
        // for transaction modal
        const isTransactionModalOpen = ref(false);
        const editingTransactionId = ref(null);
        const transactionForm = reactive({
          date: new Date().toISOString().split('T')[0],
          description: '',
          amount: 0,
          type: 'expense',
          merchant: '',
          account: '',
          accountType: 'bank',
          currency: 'USD',
          categoryId: '',
          tagsInput: '',
          notes: ''
        });
        const colorPalette = [
          '#EF4444', // Red
          '#F97316', // Orange  
          '#F59E0B', // Amber
          '#EAB308', // Yellow
          '#84CC16', // Lime
          '#22C55E', // Green
          '#10B981', // Emerald
          '#14B8A6', // Teal
          '#06B6D4', // Cyan
          '#0EA5E9', // Light Blue
          '#3B82F6', // Blue
          '#6366F1', // Indigo
          '#8B5CF6', // Violet
          '#A855F7', // Purple
          '#D946EF', // Fuchsia
          '#EC4899', // Pink
          '#F43F5E', // Rose
          '#64748B'  // Slate
        ];
        
        // Fetch transactions from API
        const fetchTransactions = async () => {
          state.loading.transactions = true;
          state.errors.transactions = null;
          
          try {
            state.transactions = await api.transactions.getAll();
            if (state.transactions.length > 0) {
              hasData.value = true;
            }
          } catch (error) {
            state.errors.transactions = error.message;
            console.error('Failed to fetch transactions:', error);
          } finally {
            state.loading.transactions = false;
          }
        };
        
        // Fetch categories from API
        const fetchCategories = async () => {
          state.loading.categories = true;
          state.errors.categories = null;
          
          try {
            state.categories = await api.categories.getAll();
          } catch (error) {
            state.errors.categories = error.message;
            console.error('Failed to fetch categories:', error);
          } finally {
            state.loading.categories = false;
          }
        };
        
        // Fetch dashboard data
        const fetchDashboardData = async () => {
          state.loading.reports = true;
          state.errors.reports = null;
          
          try {
            const dashboardData = await api.reports.getDashboard();
            
            // Store dashboard data in the state
            state.dashboardData = dashboardData;
            
            // Update other state properties based on dashboard data
            if (dashboardData.incomeVsExpenses) {
              state.incomeVsExpenses = dashboardData.incomeVsExpenses;
            }
            
            if (dashboardData.topMerchants) {
              state.topMerchants = dashboardData.topMerchants;
            }
            
            if (dashboardData.recentTransactions) {
              state.recentTransactions = dashboardData.recentTransactions;
            }
            
            if (dashboardData.categorization) {
              state.categorizationStatus = dashboardData.categorization;
            }
            
            console.log('Dashboard data loaded:', dashboardData);
          } catch (error) {
            state.errors.reports = error.message;
            console.error('Failed to fetch dashboard data:', error);
          } finally {
            state.loading.reports = false;
          }
        };
        
        // Fetch report data based on selected timeframe
        const fetchReportData = async () => {
          state.loading.reports = true;
          state.errors.reports = null;
          
          try {
            // Fetch category summary data
            state.reportData.categorySummary = await api.reports.getCategorySummary(selectedDateRange.value);
            
            // Fetch spending trend data
            state.reportData.spendingTrend = await api.reports.getSpendingTrend(selectedDateRange.value);
            
            // Fetch monthly finance data
            const months = selectedDateRange.value === 'month' ? 1 :
                          selectedDateRange.value === '3months' ? 3 :
                          selectedDateRange.value === '6months' ? 6 : 12;
            state.reportData.monthlyFinances = await api.reports.getMonthlyFinances(months);
            
            // Fetch budget status
            state.budgetStatus = await api.reports.getBudgetStatus();
          } catch (error) {
            state.errors.reports = error.message;
            console.error('Failed to fetch report data:', error);
          } finally {
            state.loading.reports = false;
          }
        };
        
        // Fetch settings from API
        const fetchSettings = async () => {
          state.loading.settings = true;
          state.errors.settings = null;
          
          try {
            state.settings = await api.settings.get();
          } catch (error) {
            state.errors.settings = error.message;
            console.error('Failed to fetch settings:', error);
          } finally {
            state.loading.settings = false;
          }
        };
        
        // Handle file drop (drag & drop)
        const handleFileDrop = async (event) => {
          if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
            const file = event.dataTransfer.files[0];
            await processFileUpload(file);
          }
        };
        
        // Handle file upload from input field
        const handleFileUpload = async (event) => {
          const file = event.target.files[0];
          if (!file) return;
          
          await processFileUpload(file);
        };
        
        // Process file upload (used by both drag & drop and file input)
        const processFileUpload = async (file) => {
          state.loading.upload = true;
          state.errors.upload = null;
          state.successMessages.upload = null;
          uploadProgress.value = 10;
          
          try {
            const formData = new FormData();
            formData.append('file', file);
            
            // Add enrichment mode flag to enable the new flow
            formData.append('enrichMode', 'true');
            
            // Simulate progress (in a real app, this would use progress events)
            let progressInterval = setInterval(() => {
              if (uploadProgress.value < 90) {
                uploadProgress.value += 10;
              } else {
                clearInterval(progressInterval);
              }
            }, 300);
            
            const result = await api.transactions.uploadFile(formData);
            
            // Clear interval and set to 100%
            clearInterval(progressInterval);
            uploadProgress.value = 100;
            
            // If result has uploadId and enrichmentMode=true, start the enrichment flow
            if (result.uploadId && result.enrichmentMode) {
              // Update state to show enrichment modal
              state.enrichment.showModal = true;
              state.enrichment.currentUploadId = result.uploadId;
              
              // Initialize uploadedFiles array if not already done
              if (!state.enrichment.uploadedFiles) {
                state.enrichment.uploadedFiles = [];
              }
              
              // Add current file to uploadedFiles with empty account info
              state.enrichment.uploadedFiles.push({
                fileName: file.name,
                fileId: result.uploadId,
                accountSource: '',
                accountSourceSelection: '',
                accountType: ''
              });
              
              state.enrichment.transactionBatches = result.batches || [];
              state.enrichment.statistics = result.statistics;
              state.enrichment.currentStep = 'accountSetup';  // Start with account setup
              state.enrichment.progress = 25; // First step completed
              
              // Show success message specifically for enrichment mode
              state.successMessages.upload = `Successfully uploaded ${file.name}. Starting transaction enrichment flow...`;
            } else {
              // Traditional flow - no enrichment
              // Refresh transactions after upload
              await fetchTransactions();
              
              hasData.value = true;
              
              // Show success message
              state.successMessages.upload = `Successfully uploaded ${file.name}. ${result.count || 'Multiple'} transactions imported.`;
            }
            
            // Reset upload progress after a delay
            setTimeout(() => {
              uploadProgress.value = 0;
              
              // Clear success message after 5 seconds
              setTimeout(() => {
                state.successMessages.upload = null;
              }, 5000);
            }, 2000);
            
            return result;
          } catch (error) {
            state.errors.upload = error.message;
            console.error('File upload failed:', error);
            uploadProgress.value = 0;
          } finally {
            state.loading.upload = false;
          }
        };
        
        // Fetch enrichment batches
        const fetchEnrichmentBatches = async (uploadId) => {
          state.loading.enrichment = true;
          state.errors.enrichment = null;
          
          try {
            console.log(` [CLIENT] Fetching batches for uploadId: ${uploadId}`);
            
            // Validate the upload ID before making the request
            if (!uploadId) {
              throw new Error('Upload ID is missing. Please try uploading the file again.');
            }
            
            // Strict validation of upload ID format
            if (!uploadId.match(/^upload_\d+$/)) {
              console.error(` [CLIENT] Invalid upload ID format: ${uploadId}`);
              throw new Error(`Invalid upload ID format: ${uploadId}. Expected format is "upload_" followed by numbers.`);
            }
            
            // Make the API request
            console.log(` [CLIENT] Making API request to get batches for upload: ${uploadId}`);
            const result = await api.transactions.getUploadedBatches(uploadId);
            
            console.log(` [CLIENT] Batches response received:`, {
              batchCount: result?.batches?.length || 0,
              statistics: result?.statistics || 'None',
              hasError: !!result?.error
            });
            
            // Check for API errors
            if (result?.error) {
              throw new Error(`API returned error: ${result.error}`);
            }
            
            // Handle empty batches case
            if (!result?.batches || !Array.isArray(result.batches) || result.batches.length === 0) {
              console.warn(` [CLIENT] No batches returned for uploadId: ${uploadId}`);
              state.errors.enrichment = 'No transaction batches were found for this upload. This may indicate an issue with the file format or data.';
              return { batches: [], statistics: result?.statistics || { totalTransactions: 0 } };
            } 
            
            // Handle successful response
            console.log(` [CLIENT] Found ${result.batches.length} batches`);
            
            // Validate batch structure
            let validBatches = result.batches.filter(batch => {
              if (!batch.batchId) {
                console.warn(` [CLIENT] Found a batch without batchId`);
                return false;
              }
              return true;
            });
            
            if (validBatches.length === 0) {
              console.error(` [CLIENT] All batches have invalid format (missing batchId)`);
              throw new Error('Batches have invalid format. Please try again or contact support.');
            }
            
            if (validBatches.length < result.batches.length) {
              console.warn(` [CLIENT] Filtered out ${result.batches.length - validBatches.length} invalid batches`);
            }
            
            // Check if batch transactions are present
            const firstBatchWithTransactions = validBatches.find(batch => 
              batch.transactions && Array.isArray(batch.transactions) && batch.transactions.length > 0
            );
            
            if (!firstBatchWithTransactions) {
              console.warn(` [CLIENT] Batches exist but contain no transactions`);
            } else {
              console.log(` [CLIENT] First batch has ${firstBatchWithTransactions.transactions.length} transactions`);
            }
            
            // Update result with valid batches
            result.batches = validBatches;
            
            // Don't store in state here - this will be done by the caller
            return result;
          } catch (error) {
            const errorMsg = `Failed to fetch enrichment batches: ${error.message}`;
            state.errors.enrichment = errorMsg;
            console.error(' [CLIENT]', errorMsg, error);
            
            // Return error object to handle it in the calling function
            return { error: errorMsg, batches: [] };
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Enrich a batch of transactions
        const enrichBatch = async (batchId, enrichData) => {
          state.loading.enrichment = true;
          state.errors.enrichment = null;
          
          try {
            const result = await api.transactions.batchEnrich(batchId, enrichData);
            
            // Update the batch in the state
            const batchIndex = state.enrichment.transactionBatches.findIndex(b => b.batchId === batchId);
            if (batchIndex !== -1) {
              state.enrichment.transactionBatches[batchIndex] = result;
            }
            
            // Move the batch from pending to processed
            state.enrichment.processedBatches.push(batchId);
            state.enrichment.pendingBatches = state.enrichment.pendingBatches.filter(id => id !== batchId);
            
            // Update progress
            updateEnrichmentProgress();
            
            return result;
          } catch (error) {
            state.errors.enrichment = error.message;
            console.error('Failed to enrich batch:', error);
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Complete a batch of transactions
        const completeBatch = async (batchId) => {
          state.loading.enrichment = true;
          
          try {
            await api.transactions.completeBatch(batchId);
            
            // Move the batch to completed status
            const batchIndex = state.enrichment.transactionBatches.findIndex(b => b.batchId === batchId);
            if (batchIndex !== -1) {
              const updatedBatch = { ...state.enrichment.transactionBatches[batchIndex], status: 'completed' };
              state.enrichment.transactionBatches[batchIndex] = updatedBatch;
            }
            
            // Update progress
            updateEnrichmentProgress();
          } catch (error) {
            console.error('Failed to complete batch:', error);
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Complete the entire upload
        const completeUpload = async (uploadId) => {
          console.log(' [CLIENT] Starting completeUpload for uploadId:', uploadId);
          state.loading.enrichment = true;
          state.errors.enrichment = null;
          
          if (!uploadId) {
            const errorMsg = 'Missing upload ID. Cannot complete the upload process.';
            console.error(' [CLIENT] ' + errorMsg);
            state.errors.enrichment = errorMsg;
            state.loading.enrichment = false;
            return;
          }
          
          try {
            console.log(' [CLIENT] Calling API to complete upload for ID:', uploadId);
            
            // Add a timeout promise to provide a fallback if the API call takes too long
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Request timed out after 15 seconds')), 15000);
            });
            
            // Make the API call with a timeout
            const result = await Promise.race([
              api.transactions.completeUpload(uploadId),
              timeoutPromise
            ]);
            
            console.log(' [CLIENT] Upload completed successfully:', result);
            
            // Set the enrichment flow as complete
            state.enrichment.currentStep = 'complete';
            state.enrichment.progress = 100;
            console.log(' [CLIENT] Updated enrichment state: currentStep=complete, progress=100%');
            
            // Show processing message before fetching new data
            state.successMessages.enrichment = `Transaction upload complete! Refreshing data...`;
            
            try {
              // Refresh transactions and categories in parallel to show the newly imported data
              await Promise.all([
                fetchTransactions(),
                fetchCategories()
              ]);
              
              console.log(' [CLIENT] Successfully refreshed transactions and categories after upload');
              
              // Set hasData flag now that we have transactions
              hasData.value = true;
              
              // Update success message
              state.successMessages.enrichment = `Successfully imported and enriched all transactions.`;
              
              // Refresh dashboard if we're on the home tab
              if (activeTab.value === 'home') {
                fetchDashboardData().catch(err => {
                  console.warn(' [CLIENT] Failed to refresh dashboard data:', err);
                });
              }
              
              // Clear enrichment modal after a delay to show success message
              setTimeout(() => {
                closeEnrichmentModal();
              }, 3000);
              
            } catch (refreshError) {
              console.error(' [CLIENT] Failed to refresh data after upload:', refreshError);
              // Still consider the upload a success, just show a warning
              state.successMessages.enrichment = `Successfully imported transactions, but couldn't refresh the data. Try refreshing the page.`;
            }
          } catch (error) {
            const errorMsg = `Failed to complete upload: ${error.message}`;
            console.error(' [CLIENT] Error in completeUpload:', error);
            state.errors.enrichment = errorMsg;
            
            if (error.message.includes('timeout')) {
              state.errors.enrichment += ' The server might still be processing your upload in the background.';
              
              // Try to recover by checking if transactions were added anyway
              setTimeout(async () => {
                try {
                  await fetchTransactions();
                  console.log(' [CLIENT] Attempted to recover by fetching transactions after timeout');
                  
                  if (state.transactions.some(tx => tx.uploadId === uploadId)) {
                    console.log(' [CLIENT] Found transactions with this uploadId despite timeout');
                    state.successMessages.enrichment = 'Upload may have completed successfully in the background.';
                    state.errors.enrichment = null;
                  }
                } catch (e) {
                  console.error(' [CLIENT] Recovery attempt failed:', e);
                }
              }, 3000);
            }
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Update the enrichment progress
        const updateEnrichmentProgress = () => {
          const totalBatches = state.enrichment.transactionBatches.length;
          if (totalBatches === 0) return;
          
          const completedBatches = state.enrichment.transactionBatches.filter(b => 
            b.status === 'completed' || b.status === 'enriched').length;
          
          // Calculate progress percentage (25% for upload, 75% for batches)
          const batchProgress = completedBatches / totalBatches * 75;
          state.enrichment.progress = 25 + batchProgress;
          
          // Update step if all batches are completed
          if (completedBatches === totalBatches) {
            state.enrichment.currentStep = 'complete';
            state.enrichment.progress = 100;
          }
        };
        
        // Close the enrichment modal
        const closeEnrichmentModal = () => {
          state.enrichment.showModal = false;
          state.enrichment.currentUploadId = null;
          state.enrichment.transactionBatches = [];
          state.enrichment.processedBatches = [];
          state.enrichment.pendingBatches = [];
          state.enrichment.uploadedFiles = [];
          state.enrichment.currentStep = 'accountSetup';
          state.enrichment.progress = 0;
          state.enrichment.statistics = null;
        };
        
        // Check if all account setup details are complete
        const areAccountDetailsComplete = () => {
          // Check if any uploaded files exist
          if (!state.enrichment.uploadedFiles || state.enrichment.uploadedFiles.length === 0) {
            return false;
          }
          
          // Check if all files have account source and type
          return state.enrichment.uploadedFiles.every(file => 
            file.accountSource && file.accountSource.trim() !== '' && 
            file.accountType && file.accountType.trim() !== ''
          );
        };
        
        // Update account source when selection changes
        const updateAccountSource = (file) => {
          // If the selection is 'other', keep the text input field visible
          // Otherwise, set the accountSource to the selected value
          if (file.accountSourceSelection !== 'other') {
            file.accountSource = file.accountSourceSelection;
          }
        };

        // Process account setup and move to next step
        const processAccountSetup = async () => {
          console.log(' [CLIENT] Processing account setup', { 
            uploadedFiles: state.enrichment.uploadedFiles,
            uploadId: state.enrichment.currentUploadId
          });
          
          if (!areAccountDetailsComplete()) {
            console.warn(' [CLIENT] Account details are not complete, skipping process');
            state.errors.enrichment = 'Please complete all account details before proceeding';
            return;
          }
          
          if (!state.enrichment.currentUploadId) {
            console.error(' [CLIENT] Missing uploadId, cannot proceed');
            state.errors.enrichment = 'Upload ID is missing. Please try uploading the file again.';
            return;
          }
          
          state.loading.enrichment = true;
          state.errors.enrichment = null;
          
          try {
            console.log(' [CLIENT] Updating account information in the backend', {
              uploadId: state.enrichment.currentUploadId,
              files: state.enrichment.uploadedFiles.map(f => ({ 
                fileName: f.fileName,
                fileId: state.enrichment.currentUploadId,
                accountSource: f.accountSource, 
                accountSourceSelection: f.accountSourceSelection || f.accountSource,
                accountType: f.accountType 
              }))
            });
            
            // Update account information in the backend
            await api.transactions.updateAccountInfo(
              state.enrichment.currentUploadId, 
              state.enrichment.uploadedFiles.map(f => ({
                fileName: f.fileName,
                fileId: state.enrichment.currentUploadId,
                accountSource: f.accountSource,
                accountSourceSelection: f.accountSourceSelection || f.accountSource,
                accountType: f.accountType
              }))
            );
            
            console.log(' [CLIENT] Account information updated successfully');
            
            // First update UI to show loading in batching step
            state.enrichment.currentStep = 'batching';
            state.enrichment.progress = 40;
            
            // The batching step should show a loading state until data is ready
            state.loading.enrichment = true;
            
            try {
              // Wait a small amount of time to ensure the UI updates before making the next API call
              // This helps prevent the UI from appearing to hang
              await new Promise(resolve => setTimeout(resolve, 500));
              
              console.log(' [CLIENT] Fetching enrichment batches for upload', state.enrichment.currentUploadId);
              
              // Define a function to retry the batch fetching with exponential backoff
              const fetchBatchesWithRetry = async (uploadId, maxRetries = 3, initialDelay = 1000) => {
                let retryCount = 0;
                let lastError = null;
                
                while (retryCount < maxRetries) {
                  try {
                    // Wait an increasing amount of time between retries
                    const delay = initialDelay * Math.pow(2, retryCount);
                    console.log(` [CLIENT] Fetching batches attempt ${retryCount + 1}/${maxRetries}, waiting ${delay}ms first`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    
                    // Make the API call with a timeout
                    const timeoutPromise = new Promise((_, reject) => {
                      setTimeout(() => reject(new Error(`Attempt ${retryCount + 1} timed out after 15 seconds`)), 15000);
                    });
                    
                    const result = await Promise.race([
                      fetchEnrichmentBatches(uploadId),
                      timeoutPromise
                    ]);
                    
                    // Detect error in response
                    if (result && result.error) {
                      throw new Error(result.error);
                    }
                    
                    // Check if we got valid data back
                    if (result && result.batches && result.batches.length > 0) {
                      console.log(` [CLIENT] Successfully fetched ${result.batches.length} batches on attempt ${retryCount + 1}`);
                      return result;
                    } else {
                      console.warn(` [CLIENT] Got empty or invalid batch response on attempt ${retryCount + 1}`);
                      lastError = new Error('No valid batches returned');
                    }
                  } catch (error) {
                    console.error(` [CLIENT] Error fetching batches (attempt ${retryCount + 1}):`, error);
                    lastError = error;
                  }
                  
                  retryCount++;
                }
                
                // If we get here, all retries failed
                throw lastError || new Error('Failed to fetch batches after multiple attempts');
              };
              
              // Fetch batches with retry logic
              const batchResult = await fetchBatchesWithRetry(state.enrichment.currentUploadId);
              
              console.log(' [CLIENT] Enrichment batches processed', {
                batches: batchResult?.batches?.length || 0,
                statistics: batchResult?.statistics
              });
              
              // If no batches were returned, display an error
              if (!batchResult?.batches || batchResult.batches.length === 0) {
                state.errors.enrichment = 'No transaction batches were found for this upload. Please try again or contact support.';
                console.error(' [CLIENT] No batches returned from API');
                
                // Stay on the account setup step if there's an error
                state.enrichment.currentStep = 'accountSetup';
                state.enrichment.progress = 25;
              } else {
                // Show success message
                state.successMessages.enrichment = `Ready to process ${batchResult.batches.length} batch(es) with ${batchResult.statistics?.totalTransactions || 0} transactions.`;
                console.log(' [CLIENT] Successfully moved to batching step');
                
                // Store the latest batch data in state
                state.enrichment.transactionBatches = batchResult.batches;
                state.enrichment.statistics = batchResult.statistics;
                
                // Fix any batches that don't have batch IDs
                const fixedBatches = batchResult.batches.map((batch, index) => {
                  if (!batch.batchId) {
                    console.warn(` [CLIENT] Batch at index ${index} is missing a batchId, generating a synthetic one`);
                    return {
                      ...batch,
                      batchId: `synthetic_batch_${Date.now()}_${index}`
                    };
                  }
                  return batch;
                });
                
                // Store fixed batches
                state.enrichment.transactionBatches = fixedBatches;
                
                // Prepare pendingBatches array with all batch IDs (now all should be valid)
                const validBatchIds = fixedBatches.map(batch => batch.batchId);
                
                console.log(` [CLIENT] All ${validBatchIds.length} batches now have valid batch IDs`);
                
                state.enrichment.pendingBatches = validBatchIds;
                
                // Set first batch as current if available
                if (fixedBatches.length > 0) {
                  state.enrichment.currentBatch = fixedBatches[0];
                  state.enrichment.currentBatchIndex = 0;
                }
                
                // Make sure we're in the right state if batches were found 
                state.enrichment.currentStep = 'batching';
                state.enrichment.progress = 50;
              }
            } catch (batchError) {
              console.error(' [CLIENT] Error fetching batches:', batchError);
              state.errors.enrichment = `Failed to load transaction batches: ${batchError.message}`;
              
              // Stay on the account setup step if there's an error
              state.enrichment.currentStep = 'accountSetup';
              state.enrichment.progress = 25;
            }
          } catch (error) {
            const errorMsg = `Failed to process account setup: ${error.message}`;
            console.error(' [CLIENT] Error in processAccountSetup:', error);
            state.errors.enrichment = errorMsg;
            // Stay on the account setup step if there's an error
            state.enrichment.currentStep = 'accountSetup';
            state.enrichment.progress = 25;
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Apply enrichment to selected batches
        const applyEnrichmentToBatches = async () => {
          if (!state.enrichment.pendingBatches || state.enrichment.pendingBatches.length === 0) {
            return;
          }
          
          state.loading.enrichment = true;
          state.errors.enrichment = null;
          
          try {
            // Build the enrichment data
            const enrichData = {
              categoryId: batchCategoryId.value,
              tags: batchTags.value ? batchTags.value.split(',').map(t => t.trim()) : [],
              notes: batchNotes.value
            };
            
            // Process each pending batch
            const enrichPromises = state.enrichment.pendingBatches.map(batchId => 
              enrichBatch(batchId, enrichData)
            );
            
            // Wait for all batches to be processed
            await Promise.all(enrichPromises);
            
            // Update progress
            updateEnrichmentProgress();
            
            // Clear form
            batchCategoryId.value = '';
            batchTags.value = '';
            batchNotes.value = '';
            
            // Show success message
            state.successMessages.enrichment = `Successfully enriched ${state.enrichment.pendingBatches.length} batch(es).`;
            
            // Clear pending batches
            state.enrichment.pendingBatches = [];
            
            // If all batches are processed, move to complete step
            const areAllBatchesProcessed = state.enrichment.transactionBatches.every(
              batch => batch.status === 'completed' || batch.status === 'enriched'
            );
            
            if (areAllBatchesProcessed) {
              state.enrichment.currentStep = 'complete';
              state.enrichment.progress = 100;
            }
          } catch (error) {
            state.errors.enrichment = error.message || 'Failed to apply enrichment';
            console.error('Failed to apply enrichment:', error);
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Use sample data (for development/demo)
        const useSampleData = () => {
          hasData.value = true;
          uploadProgress.value = 60;
          
          // Simulate API call delay
          setTimeout(() => {
            uploadProgress.value = 100;
            
            // Reset upload progress after delay
            setTimeout(() => {
              uploadProgress.value = 0;
            }, 2000);
          }, 1500);
        };
        
        const setUploadActive = (active) => {
          isUploadActive.value = active;
        };
        
        // Handle date range selection
        const setDateRange = (range) => {
          selectedDateRange.value = range;
          fetchReportData();
        };
        

        
        // Get batch description based on the content
        const getBatchDescription = (batch) => {
          if (!batch || !batch.transactions || batch.transactions.length === 0) {
            return '';
          }
          
          // Helper function to extract merchant name from description
          const extractMerchant = (description) => {
            if (!description) return null;
            
            // Common patterns for merchant names in transaction descriptions
            const merchantPatterns = [
              // Credit card format with location: "MERCHANT NAME      CITY"
              /^([A-Z0-9\s]{3,}?)\s{2,}[A-Z\s]+$/,
              // Format with numbers and dates at end: "MERCHANT NAME 123456 03/15"
              /^([A-Z0-9\s]{3,}?)\s+\d+\s+\d+\/\d+$/,
              // Generic merchant at start of description
              /^([A-Z0-9\s&]{3,}?)(?:\s+-|\s{2,}|\d{4,}|$)/
            ];
            
            for (const pattern of merchantPatterns) {
              const match = description?.match?.(pattern);
              if (match && match[1]) {
                return match[1].trim();
              }
            }
            
            // Fallback to first 3 words if no pattern matches
            return description?.split?.(/ +/)?.slice?.(0, 3)?.join(' ') || '';
          };
          
          // Try to get common patterns from descriptions if merchants aren't available
          const descriptions = batch.transactions.map(t => t.description).filter(Boolean);
          const providedMerchants = batch.transactions.map(t => t.merchant).filter(Boolean);
          
          // Extract merchants from descriptions when not provided
          const extractedMerchants = descriptions.map(extractMerchant).filter(Boolean);
          const allMerchants = [...providedMerchants, ...extractedMerchants];
          
          if (allMerchants.length > 0) {
            // Count occurrences of each merchant
            const merchantCounts = {};
            allMerchants.forEach(m => {
              merchantCounts[m] = (merchantCounts[m] || 0) + 1;
            });
            
            // Find the most common merchant
            const mostCommonMerchant = Object.keys(merchantCounts).reduce((a, b) => 
              merchantCounts[a] > merchantCounts[b] ? a : b
            );
            
            // Calculate percentage of transactions with this merchant
            const merchantPercentage = Math.round((merchantCounts[mostCommonMerchant] / allMerchants.length) * 100);
            
            // If most merchants are the same (>70%), use the merchant name as the batch title
            if (merchantPercentage > 70) {
              return `${mostCommonMerchant}  ${batch.transactions.length} transactions`;
            }
          }
          
          // If no clear merchant pattern, check for transaction type pattern
          const incomeCount = batch.transactions.filter(t => t.type === 'income').length;
          const expenseCount = batch.transactions.filter(t => t.type === 'expense').length;
          
          // If mostly one type, use that in the description
          if (incomeCount > expenseCount && incomeCount > (batch.transactions.length * 0.7)) {
            return `Income Transactions  ${batch.transactions.length} items`;
          } else if (expenseCount > incomeCount && expenseCount > (batch.transactions.length * 0.7)) {
            return `Expense Transactions  ${batch.transactions.length} items`;
          }
          
          // If no clear patterns, try to find common words in descriptions
          if (descriptions.length > 0) {
            // Get first word of each description
            const firstWords = descriptions.map(d => d.split(' ')[0]).filter(Boolean);
            
            // Find most common first word
            const wordCounts = {};
            firstWords.forEach(word => {
              wordCounts[word] = (wordCounts[word] || 0) + 1;
            });
            
            const mostCommonWord = Object.keys(wordCounts).reduce((a, b) => 
              wordCounts[a] > wordCounts[b] ? a : b, ''
            );
            
            if (mostCommonWord && wordCounts[mostCommonWord] > (descriptions.length * 0.4)) {
              return `${mostCommonWord}...  ${batch.transactions.length} transactions`;
            }
            
            // Last resort: use the first few words of the first description
            const firstDescription = descriptions[0] || '';
            const words = firstDescription.split(' ').slice(0, 2).join(' ');
            
            return `${words}...  ${batch.transactions.length} transactions`;
          }
          
          // Fallback for truly unclassifiable batches
          return `Batch  ${batch.transactions.length} transactions`;
        };
        
        // Get sample transactions for display
        const getSampleTransactions = (batch, limit = 3) => {
          if (!batch || !batch.transactions || batch.transactions.length === 0) {
            return [];
          }
          
          return batch.transactions.slice(0, limit);
        };
        
        // Review a batch (start Tinder-style review)
        const reviewBatch = (batchId) => {
          // Find the batch
          const batch = state.enrichment.transactionBatches.find(b => b.batchId === batchId);
          if (!batch) return;
          
          // Set up the batch for review
          state.enrichment.currentBatch = batch;
          state.enrichment.currentBatchIndex = state.enrichment.transactionBatches.findIndex(b => b.batchId === batchId);
          state.enrichment.pendingBatches = [batchId];
          
          // Try to suggest a category based on merchant or description
          suggestCategoryForBatch(batch);
          
          // Move to enrichment step
          state.enrichment.currentStep = 'enrichment';
          state.enrichment.progress = 75;
        };
        
        // Suggest a category for the current batch using AI service
        const suggestCategoryForBatch = async (batch) => {
          if (!batch || !batch.transactions || batch.transactions.length === 0) {
            state.enrichment.suggestedCategory = null;
            return;
          }
          
          // Reset AI suggestions state
          state.enrichment.suggestedCategory = null;
          state.enrichment.suggestedCategoryConfidence = 0;
          state.enrichment.aiSuggestions = {
            topCategories: [],
            reasoning: null,
            source: null
          };
          
          // Show loading indicator for suggestions
          state.loading.suggestions = true;
          state.errors.suggestions = null;
          
          try {
            console.log(` [CLIENT] Requesting AI category suggestions for batch: ${batch.batchId}`);
            
            // Use the AI-powered suggestion service
            const result = await api.transactions.generateCategorySuggestions(
              batch.batchId, 
              0.7 // Default confidence threshold
            );
            
            console.log(` [CLIENT] AI suggestion result:`, {
              batchCategory: result.batchCategoryId || 'None',
              confidence: result.averageConfidence || 0,
              source: result.suggestionSource || 'unknown',
              needsReview: result.needsReview,
              topCategories: result.topCategories?.length || 0
            });
            
            // Store the suggested category and other data
            state.enrichment.suggestedCategory = result.batchCategoryId;
            state.enrichment.suggestedCategoryConfidence = result.averageConfidence || 0;
            
            // Store full AI suggestion data
            state.enrichment.aiSuggestions = {
              topCategories: result.topCategories || [],
              reasoning: result.reasoning || null,
              source: result.suggestionSource || null
            };
            
            // If no category was suggested or confidence is very low, fallback to keyword matching
            if (!state.enrichment.suggestedCategory) {
              console.log(` [CLIENT] No AI category suggestions available, falling back to keyword matching`);
              
              // Get the merchant names and descriptions for fallback
              const merchants = batch.transactions.map(t => t.merchant).filter(Boolean);
              const descriptions = batch.transactions.map(t => t.description);
              
              // Simple suggestion based on merchant or description keywords
              const merchantKeywords = {
                "UBER": "5fe9a5e7-09c8-4d6e-8a92-b1073e6b8a3e", // Transportation
                "AMAZON": "46c0235a-926b-4ce2-92a3-c1a93334b552", // Shopping
                "NETFLIX": "89e1743d-12c4-42de-9a3b-b4c5de09d455", // Entertainment
                "GROCERY": "b24f9d8c-7f37-4079-b1c7-b215be31e559", // Groceries
                "RESTAURANT": "1e5f61f3-43a9-4bac-b0c5-d1e35a9a75b6", // Dining Out
                "COFFEE": "1e5f61f3-43a9-4bac-b0c5-d1e35a9a75b6", // Dining Out
                "GYM": "a0c47efd-de41-4f67-b3a7-46a4f6af6f7c", // Health & Fitness
                "SALARY": "cb7a07ad-1a65-4e92-aae0-63a958d4c3c2", // Salary & Wages
                "INTEREST": "102e0968-f6a4-4e35-8405-7f53a8f18a88", // Other Income
            "RENT": "f4c6b082-5adb-454e-8ec9-d84dbf6c8f28", // Housing
            "MORTGAGE": "f4c6b082-5adb-454e-8ec9-d84dbf6c8f28", // Housing
            "INSURANCE": "c29c548c-2b8c-4733-8b92-add6e1c1c276", // Insurance
            "UTILITY": "58b5d0c1-5d1d-4826-93a0-39f65646b313", // Utilities
            "PHONE": "58b5d0c1-5d1d-4826-93a0-39f65646b313", // Utilities
            "INTERNET": "58b5d0c1-5d1d-4826-93a0-39f65646b313", // Utilities
            "CABLE": "58b5d0c1-5d1d-4826-93a0-39f65646b313", // Utilities
            "TRAVEL": "9d0b0c1c-1ec9-4681-947f-25746f339dd0", // Travel
            "HOTEL": "9d0b0c1c-1ec9-4681-947f-25746f339dd0", // Travel
            "FLIGHT": "9d0b0c1c-1ec9-4681-947f-25746f339dd0", // Travel
            "MEDICAL": "a0c47efd-de41-4f67-b3a7-46a4f6af6f7c", // Health & Fitness
            "DOCTOR": "a0c47efd-de41-4f67-b3a7-46a4f6af6f7c", // Health & Fitness
            "PHARMACY": "a0c47efd-de41-4f67-b3a7-46a4f6af6f7c", // Health & Fitness
            "EDUCATION": "35d53d3f-fb23-4edd-9df3-e842be8438db", // Education
            "TUITION": "35d53d3f-fb23-4edd-9df3-e842be8438db", // Education
            "GAS": "5fe9a5e7-09c8-4d6e-8a92-b1073e6b8a3e", // Transportation
            "PARKING": "5fe9a5e7-09c8-4d6e-8a92-b1073e6b8a3e", // Transportation
            "AUTOMOBILE": "5fe9a5e7-09c8-4d6e-8a92-b1073e6b8a3e", // Transportation
            "CAR": "5fe9a5e7-09c8-4d6e-8a92-b1073e6b8a3e", // Transportation
            "MEMBERSHIP": "89e1743d-12c4-42de-9a3b-b4c5de09d455", // Entertainment
            "SUBSCRIPTION": "89e1743d-12c4-42de-9a3b-b4c5de09d455", // Entertainment
            "DONATION": "dc4f8a91-0d44-4d7a-85df-8e1e25dc5f1f", // Donations
            "CHARITY": "dc4f8a91-0d44-4d7a-85df-8e1e25dc5f1f", // Donations
            "TAX": "e3e96c58-8d91-4e1a-bc7c-2a85e0d8a1e9", // Taxes
            "BILL": "db2b1dbe-5c8c-468e-a385-d18b3d928b0a", // Bills
            "PAYMENT": "db2b1dbe-5c8c-468e-a385-d18b3d928b0a" // Bills
          };
          
          // Check transaction type (income/expense) to suggest appropriate category
          const isIncome = batch.transactions[0]?.type === 'income';
          
          // For income transactions, suggest income categories
          if (isIncome) {
            for (const keyword of ["SALARY", "INTEREST", "PAYMENT RECEIVED"]) {
              if (merchants.some(m => m && m.toUpperCase().includes(keyword)) || 
                  descriptions.some(d => d && d.toUpperCase().includes(keyword))) {
                state.enrichment.suggestedCategory = merchantKeywords[keyword.split(' ')[0]] || "cb7a07ad-1a65-4e92-aae0-63a958d4c3c2"; // Default to Salary & Wages
                return;
              }
            }
            
            // Default income category
            state.enrichment.suggestedCategory = "cb7a07ad-1a65-4e92-aae0-63a958d4c3c2"; // Salary & Wages
            return;
          }
          
          // For expense transactions, check for keyword matches
          for (const keyword in merchantKeywords) {
            if (merchants.some(m => m && m.toUpperCase().includes(keyword)) || 
                descriptions.some(d => d && d.toUpperCase().includes(keyword))) {
              state.enrichment.suggestedCategory = merchantKeywords[keyword];
              return;
            }
          }
          
          // Default to Shopping for expenses
          state.enrichment.suggestedCategory = "46c0235a-926b-4ce2-92a3-c1a93334b552"; // Shopping
        };
        
        // Accept suggested category
        const acceptSuggestedCategory = async () => {
          console.log(` [CLIENT] Accept suggested category called with batch: ${state.enrichment.currentBatch?.batchId}, category: ${state.enrichment.suggestedCategory}`);
          
          if (!state.enrichment.currentBatch) {
            console.error(' [CLIENT] Cannot accept category: No current batch');
            return;
          }
          
          if (!state.enrichment.suggestedCategory) {
            console.error(' [CLIENT] Cannot accept category: No suggested category');
            // If for some reason we have no suggested category, show the category selector
            state.enrichment.showCategorySelector = true;
            return;
          }
          
          try {
            // Set the category ID
            batchCategoryId.value = state.enrichment.suggestedCategory;
            console.log(` [CLIENT] Using suggested category: ${batchCategoryId.value}`);
            
            // Apply the category to the batch
            await applyCustomCategory();
            
            // Move to the next batch
            nextBatch();
          } catch (error) {
            console.error(' [CLIENT] Error accepting suggested category:', error);
            state.errors.enrichment = `Failed to apply suggested category: ${error.message}`;
            // Try to recover by showing manual category selector
            state.enrichment.showCategorySelector = true;
          }
        };
        
        // Reject suggested category
        const rejectSuggestedCategory = () => {
          console.log(` [CLIENT] Reject suggested category called with category: ${state.enrichment.suggestedCategory}`);
          
          // Show the category selector regardless of current state
          state.enrichment.showCategorySelector = true;
          
          // Reset the suggested category
          state.enrichment.suggestedCategory = null;
          
          console.log(' [CLIENT] Showing manual category selector');
        };
        
        // Apply custom category
        const applyCustomCategory = async () => {
          if (!state.enrichment.currentBatch || !batchCategoryId.value) {
            return;
          }
          
          state.loading.enrichment = true;
          
          try {
            // Build the enrichment data
            const enrichData = {
              categoryId: batchCategoryId.value,
              tags: batchTags.value ? batchTags.value.split(',').map(t => t.trim()) : [],
              notes: batchNotes.value
            };
            
            // Enrich the batch
            await enrichBatch(state.enrichment.currentBatch.batchId, enrichData);
            
            // Reset form
            state.enrichment.showCategorySelector = false;
            batchCategoryId.value = '';
            batchTags.value = '';
            batchNotes.value = '';
            
            // Move to next batch automatically
            nextBatch();
          } catch (error) {
            state.errors.enrichment = error.message || 'Failed to apply category';
            console.error('Failed to apply custom category:', error);
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Move to previous batch
        const previousBatch = () => {
          if (state.enrichment.currentBatchIndex <= 0) {
            return;
          }
          
          state.enrichment.currentBatchIndex--;
          state.enrichment.currentBatch = state.enrichment.transactionBatches[state.enrichment.currentBatchIndex];
          state.enrichment.pendingBatches = [state.enrichment.currentBatch.batchId];
          state.enrichment.showCategorySelector = false;
          state.enrichment.suggestedCategory = null;
          
          // Suggest a category for the new batch
          suggestCategoryForBatch(state.enrichment.currentBatch);
        };
        
        // Move to next batch
        const nextBatch = () => {
          if (state.enrichment.currentBatchIndex >= state.enrichment.transactionBatches.length - 1) {
            // This was the last batch, finish review
            finishBatchReview();
            return;
          }
          
          state.enrichment.currentBatchIndex++;
          state.enrichment.currentBatch = state.enrichment.transactionBatches[state.enrichment.currentBatchIndex];
          state.enrichment.pendingBatches = [state.enrichment.currentBatch.batchId];
          state.enrichment.showCategorySelector = false;
          state.enrichment.suggestedCategory = null;
          
          // Suggest a category for the new batch
          suggestCategoryForBatch(state.enrichment.currentBatch);
        };
        
        // Check if this is the last batch
        const isLastBatch = () => {
          return state.enrichment.currentBatchIndex >= state.enrichment.transactionBatches.length - 1;
        };
        
        // Finish batch review and show completion screen
        const finishBatchReview = async () => {
          console.log(' [CLIENT] Starting finishBatchReview function');
          state.loading.enrichment = true;
          state.errors.enrichment = null;
          
          try {
            // First, ensure all batches have been processed
            const unprocessedBatches = state.enrichment.transactionBatches.filter(
              batch => !batch.status || (batch.status !== 'completed' && batch.status !== 'enriched')
            );
            
            if (unprocessedBatches.length > 0) {
              console.warn(` [CLIENT] There are ${unprocessedBatches.length} unprocessed batches`);
              
              // Automatically complete any remaining batches
              console.log(` [CLIENT] Auto-completing ${unprocessedBatches.length} remaining batches`);
              
              for (const batch of unprocessedBatches) {
                try {
                  await completeBatch(batch.batchId);
                  console.log(` [CLIENT] Auto-completed batch: ${batch.batchId}`);
                } catch (batchError) {
                  console.error(` [CLIENT] Failed to auto-complete batch ${batch.batchId}:`, batchError);
                  // Continue with other batches even if one fails
                }
              }
            }
            
            console.log(' [CLIENT] Calling completeUpload with uploadId:', state.enrichment.currentUploadId);
            
            // Add a fallback if somehow uploadId is missing
            if (!state.enrichment.currentUploadId) {
              console.error(' [CLIENT] Error: Missing uploadId in finishBatchReview');
              
              // Try to recover by finding the first batch and extracting uploadId
              if (state.enrichment.transactionBatches && state.enrichment.transactionBatches.length > 0) {
                const firstBatch = state.enrichment.transactionBatches[0];
                if (firstBatch.batchId) {
                  const uploadIdMatch = firstBatch.batchId.match(/^(upload_\d+)_/);
                  if (uploadIdMatch && uploadIdMatch[1]) {
                    console.log(' [CLIENT] Recovered uploadId from batch:', uploadIdMatch[1]);
                    state.enrichment.currentUploadId = uploadIdMatch[1];
                  } else {
                    throw new Error('Could not extract uploadId from batch ID: ' + firstBatch.batchId);
                  }
                } else {
                  throw new Error('Batch ID is missing from the first batch');
                }
              } else {
                throw new Error('No transaction batches found for recovery');
              }
            }
            
            // Verify we now have a valid uploadId
            if (!state.enrichment.currentUploadId) {
              throw new Error('Unable to recover the upload ID. Please start over.');
            }
            
            // Show a loading message
            state.successMessages.enrichment = "Finalizing your transaction upload...";
            
            // Complete the upload
            await completeUpload(state.enrichment.currentUploadId);
            
            // Move to complete step
            state.enrichment.currentStep = 'complete';
            state.enrichment.progress = 100;
            console.log(' [CLIENT] Completed batch review successfully');
            
            // Show success message
            state.successMessages.enrichment = `Successfully processed all transaction batches. Your transactions are now ready!`;
          } catch (error) {
            const errorMsg = `Failed to complete transaction processing: ${error.message}`;
            state.errors.enrichment = errorMsg;
            console.error(' [CLIENT] Error in finishBatchReview:', error);
            
            // Try to notify the user about specific issues
            if (error.message.includes('uploadId')) {
              state.errors.enrichment += ' This might be due to a missing upload ID. Please try uploading the file again.';
            } else if (error.message.includes('network')) {
              state.errors.enrichment += ' This might be due to a network issue. Please check your connection and try again.';
            }
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Debugging function to log batch state
        const debugBatchState = () => {
          console.log(' [CLIENT] Debug Batch State:', {
            currentStep: state.enrichment.currentStep,
            batchCount: state.enrichment.transactionBatches?.length || 0,
            pendingBatchCount: state.enrichment.pendingBatches?.length || 0,
            processedBatchCount: state.enrichment.processedBatches?.length || 0,
            firstBatchId: state.enrichment.transactionBatches?.[0]?.batchId || 'none',
            currentBatchId: state.enrichment.currentBatch?.batchId || 'none',
            uploadId: state.enrichment.currentUploadId,
            hasCurrentBatch: !!state.enrichment.currentBatch,
            progress: state.enrichment.progress,
            hasErrors: !!state.errors.enrichment,
            errorMsg: state.errors.enrichment || 'none'
          });
          
          // Check if batches contain transactions
          if (state.enrichment.transactionBatches && state.enrichment.transactionBatches.length > 0) {
            const batchDetails = state.enrichment.transactionBatches.map(b => ({
              batchId: b.batchId || 'missing-id',
              txCount: b.transactions?.length || 0,
              description: getBatchDescription(b) || 'No description'
            }));
            console.log(' [CLIENT] Batch details:', batchDetails);
            
            // Check for consistency between currentUploadId and batch IDs
            if (state.enrichment.currentUploadId && state.enrichment.transactionBatches.length > 0) {
              // Extract upload ID part from batch IDs (if using format uploadId_batch_index)
              const batchUploadIds = state.enrichment.transactionBatches
                .map(b => b.batchId?.split('_batch_')[0] || 'unknown')
                .filter((value, index, self) => self.indexOf(value) === index); // get unique values
                
              if (batchUploadIds.length > 1) {
                console.warn(' [CLIENT] Multiple upload IDs found in batches:', batchUploadIds);
              }
              
              if (!batchUploadIds.includes(state.enrichment.currentUploadId)) {
                console.error(' [CLIENT] Current upload ID does not match any batch upload ID!', {
                  currentUploadId: state.enrichment.currentUploadId,
                  batchUploadIds
                });
                
                // Try to fix by extracting uploadId from first batch
                if (batchUploadIds[0] && batchUploadIds[0] !== 'unknown') {
                  console.log(' [CLIENT] Automatically fixing uploadId mismatch by updating currentUploadId');
                  state.enrichment.currentUploadId = batchUploadIds[0];
                }
              }
            }
          }
          
          // Check if pendingBatches are valid
          if (state.enrichment.pendingBatches && state.enrichment.pendingBatches.length > 0) {
            const validPendingBatches = state.enrichment.pendingBatches.filter(batchId => {
              const batchExists = state.enrichment.transactionBatches.some(b => b.batchId === batchId);
              if (!batchExists) {
                console.error(` [CLIENT] Pending batch ID ${batchId} does not exist in transactionBatches`);
              }
              return batchExists;
            });
            
            // Fix pendingBatches if needed
            if (validPendingBatches.length !== state.enrichment.pendingBatches.length) {
              console.log(' [CLIENT] Fixing pendingBatches array by removing invalid batch IDs');
              state.enrichment.pendingBatches = validPendingBatches;
            }
          }
        };
        
        // Force refresh batches in case of issues
        const forceRefreshBatches = async (retryCount = 0, maxRetries = 3) => {
          if (!state.enrichment.currentUploadId) {
            console.error(' [CLIENT] Cannot refresh batches: No upload ID');
            return false;
          }
          
          const retryMessage = retryCount > 0 ? ` (Retry ${retryCount}/${maxRetries})` : '';
          console.log(` [CLIENT] Force refreshing batches for upload: ${state.enrichment.currentUploadId}${retryMessage}`);
          
          // Set the loading state and ensure errors are cleared
          state.loading.enrichment = true;
          
          // Create an independent controller for this request that we can abort
          const controller = new AbortController();
          const signal = controller.signal;
          
          // Set up a timeout to abort the request if it takes too long
          const timeoutId = setTimeout(() => {
            controller.abort();
            console.warn(' [CLIENT] Batch refresh request aborted due to timeout');
          }, 12000); // 12 second timeout
          
          try {
            console.log(` [CLIENT] Starting batch refresh request with timeout protection`);
            
            // Make the API request with abort signal
            const result = await api.transactions.getUploadedBatches(
              state.enrichment.currentUploadId, 
              { signal }
            );
            
            // Clear the timeout since request completed normally
            clearTimeout(timeoutId);
            
            if (result && result.batches && result.batches.length > 0) {
              console.log(` [CLIENT] Successfully refreshed batches: found ${result.batches.length} batches`);
              state.enrichment.transactionBatches = result.batches;
              state.enrichment.statistics = result.statistics;
              state.errors.enrichment = "";
              
              // Set success message
              state.successMessages.enrichment = `Refreshed ${result.batches.length} batches successfully.`;
              
              // Verify batches have proper IDs
              const missingBatchIds = result.batches.filter(batch => !batch.batchId).length;
              if (missingBatchIds > 0) {
                console.warn(` [CLIENT] Found ${missingBatchIds} batches without IDs`);
                state.errors.enrichment = `Warning: ${missingBatchIds} batches are missing IDs. This may cause issues.`;
                return false;
              }
              
              return true;
            } else {
              console.warn(' [CLIENT] Refresh returned no batches');
              
              // Add retry logic
              if (retryCount < maxRetries) {
                console.log(` [CLIENT] Retrying batch refresh (${retryCount + 1}/${maxRetries})...`);
                
                // Ensure loading state is reset before retry
                state.loading.enrichment = false;
                
                // Exponential backoff: wait longer between each retry
                const backoffTime = Math.pow(2, retryCount) * 1000;
                await new Promise(resolve => setTimeout(resolve, backoffTime));
                
                return await forceRefreshBatches(retryCount + 1, maxRetries);
              }
              
              state.errors.enrichment = 'No batches found. Please try uploading again.';
              return false;
            }
          } catch (error) {
            // Clear the timeout to prevent double handling
            clearTimeout(timeoutId);
            
            if (error.name === 'AbortError' || error.message.includes('abort')) {
              console.error(' [CLIENT] Batch refresh request aborted:', error);
              state.errors.enrichment = 'Batch refresh timed out. Please try again.';
              
              // Special case for timeouts - try one more time with increased timeout
              if (retryCount < maxRetries) {
                console.log(` [CLIENT] Retrying after timeout (${retryCount + 1}/${maxRetries})...`);
                state.loading.enrichment = false;
                
                // Wait a bit longer before retry after timeout
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                return await forceRefreshBatches(retryCount + 1, maxRetries);
              }
              
              return false;
            }
            
            console.error(' [CLIENT] Error refreshing batches:', error);
            
            // Add retry logic for other errors
            if (retryCount < maxRetries) {
              console.log(` [CLIENT] Retrying batch refresh after error (${retryCount + 1}/${maxRetries})...`);
              state.loading.enrichment = false;
              
              // Exponential backoff: wait longer between each retry
              const backoffTime = Math.pow(2, retryCount) * 1000;
              await new Promise(resolve => setTimeout(resolve, backoffTime));
              
              return await forceRefreshBatches(retryCount + 1, maxRetries);
            }
            
            state.errors.enrichment = `Failed to refresh batches: ${error.message}`;
            return false;
          } finally {
            // Always ensure loading state is cleared when we're done
            if (retryCount === maxRetries) {
              state.loading.enrichment = false;
            }
          }
        };
        
        // Start process to enrich all batches at once
        const startEnrichAllBatches = async () => {
          console.log(' [CLIENT] Starting enrichment for all batches');
          debugBatchState();
          
          state.loading.enrichment = true;
          state.errors.enrichment = null;
          state.successMessages.enrichment = null; // Clear any previous success messages
          
          try {
            // First validate we have an upload ID
            if (!state.enrichment.currentUploadId) {
              console.error(' [CLIENT] Cannot start enrichment: No upload ID');
              state.errors.enrichment = 'Upload ID is missing. Please try uploading the file again.';
              state.loading.enrichment = false;
              return;
            }
            
            // Validate that we have batches to process
            if (!state.enrichment.transactionBatches || state.enrichment.transactionBatches.length === 0) {
              console.warn(' [CLIENT] Cannot start enrichment: No batches available');
              
              // Try to refresh batches with our improved forceRefreshBatches function
              console.log(' [CLIENT] Attempting to refresh batches before enrichment');
              const refreshSuccessful = await forceRefreshBatches();
              
              if (!refreshSuccessful) {
                console.error(' [CLIENT] Failed to refresh batches after multiple attempts');
                state.errors.enrichment = 'No batches available for enrichment. Please try uploading again.';
                state.loading.enrichment = false;
                return;
              }
              
              // Check if refresh was successful but still no batches
              if (!state.enrichment.transactionBatches || state.enrichment.transactionBatches.length === 0) {
                console.error(' [CLIENT] Refresh completed but still no batches available');
                state.errors.enrichment = 'Refresh completed but no batches were found.';
                state.loading.enrichment = false;
                return;
              }
              
              console.log(' [CLIENT] Successfully refreshed batches before enrichment');
            }
            
            // Reset any previous enrichment errors
            state.errors.enrichment = null;
            
            // Make sure all batches have valid batch IDs
            const invalidBatches = state.enrichment.transactionBatches.filter(b => !b.batchId);
            if (invalidBatches.length > 0) {
              console.error(` [CLIENT] Found ${invalidBatches.length} batches without batch IDs`);
              console.log(' [CLIENT] Creating synthetic batch IDs for invalid batches');
              
              // Fix invalid batches with synthetic IDs
              state.enrichment.transactionBatches = state.enrichment.transactionBatches.map(batch => {
                if (!batch.batchId) {
                  return {
                    ...batch,
                    batchId: `synthetic_batch_${Date.now()}_${Math.floor(Math.random() * 1000)}`
                  };
                }
                return batch;
              });
              
              console.log(' [CLIENT] Fixed invalid batches with synthetic IDs');
            }
            
            // Prepare for batch enrichment
            state.enrichment.pendingBatches = state.enrichment.transactionBatches
              .filter(b => b.batchId) // Extra safety filter
              .map(b => b.batchId);
            
            state.enrichment.currentBatchIndex = 0;
            
            console.log(` [CLIENT] Prepared ${state.enrichment.pendingBatches.length} batches for enrichment`);
            
            // Set the first batch as current
            if (state.enrichment.pendingBatches.length > 0) {
              const firstBatchId = state.enrichment.pendingBatches[0];
              const firstBatch = state.enrichment.transactionBatches.find(b => b.batchId === firstBatchId);
              
              if (!firstBatch) {
                console.error(` [CLIENT] Could not find batch with ID ${firstBatchId}`);
                throw new Error(`Could not find batch with ID ${firstBatchId}`);
              }
              
              state.enrichment.currentBatch = firstBatch;
              
              // Generate category suggestions for first batch
              suggestCategoryForBatch(firstBatch);
              console.log(` [CLIENT] Set current batch and generated category suggestions`);
            } else {
              console.error(' [CLIENT] No valid pending batches available');
              throw new Error('No valid batches found for processing');
            }
            
            // Update progress and move to enrichment step
            state.enrichment.progress = 75;
            state.enrichment.currentStep = 'enrichment';
            console.log(` [CLIENT] Successfully moved to enrichment step`);
            
            // Final debug log after state changes
            debugBatchState();
          } catch (error) {
            console.error(' [CLIENT] Error starting enrichment:', error);
            state.errors.enrichment = `Failed to start enrichment: ${error.message}`;
            
            // Stay on batching step if there's an error
            state.enrichment.currentStep = 'batching';
            state.loading.enrichment = false;
          }
        };
        
        // Get suggested categories for a specific batch based on content
        const getSuggestedCategoriesForBatch = (batch) => {
          if (!batch || !batch.transactions || batch.transactions.length === 0 || !state.categories) {
            return [];
          }
          
          // Helper function to determine if a keyword is present
          const containsKeyword = (text, keyword) => {
            if (!text) return false;
            return text.toUpperCase().includes(keyword);
          };
          
          const transactions = batch.transactions;
          const descriptions = transactions.map(t => t.description).filter(Boolean);
          const merchants = transactions.map(t => t.merchant).filter(Boolean);
          const isExpenseBatch = transactions.some(t => t.type === 'expense');
          
          // Initialize category suggestion map
          const categorySuggestionScores = {};
          
          // Define keyword to category mappings
          const expenseKeywords = {
            "UBER": "Transportation", 
            "LYFT": "Transportation",
            "TAXI": "Transportation",
            "METRO": "Transportation",
            "SUBWAY": "Transportation",
            "BUS": "Transportation",
            "TRAIN": "Transportation",
            "AMAZON": "Shopping",
            "WALMART": "Shopping", 
            "TARGET": "Shopping",
            "EBAY": "Shopping",
            "NETFLIX": "Entertainment",
            "SPOTIFY": "Entertainment",
            "DISNEY": "Entertainment",
            "HULU": "Entertainment",
            "HBO": "Entertainment",
            "CINEMA": "Entertainment",
            "MOVIE": "Entertainment", 
            "TICKET": "Entertainment",
            "THEATER": "Entertainment",
            "GROCERY": "Groceries",
            "FOOD": "Groceries",
            "SUPERMARKET": "Groceries",
            "MARKET": "Groceries",
            "RESTAURANT": "Dining Out",
            "CAFE": "Dining Out",
            "COFFEE": "Dining Out",
            "BAR": "Dining Out",
            "FAST FOOD": "Dining Out",
            "GYM": "Health & Fitness",
            "FITNESS": "Health & Fitness",
            "DOCTOR": "Health & Fitness",
            "MEDICAL": "Health & Fitness",
            "PHARMACY": "Health & Fitness",
            "HOSPITAL": "Health & Fitness",
            "RENT": "Housing",
            "MORTGAGE": "Housing",
            "APARTMENT": "Housing",
            "PROPERTY": "Housing",
            "INSURANCE": "Insurance",
            "POLICY": "Insurance",
            "UTILITY": "Utilities",
            "ELECTRIC": "Utilities",
            "WATER": "Utilities",
            "GAS": "Utilities",
            "PHONE": "Utilities",
            "INTERNET": "Utilities",
            "CABLE": "Utilities",
            "TRAVEL": "Travel",
            "HOTEL": "Travel",
            "FLIGHT": "Travel",
            "AIRBNB": "Travel",
            "AIRLINE": "Travel",
            "VACATION": "Travel",
            "EDUCATION": "Education",
            "TUITION": "Education",
            "SCHOOL": "Education",
            "UNIVERSITY": "Education",
            "COLLEGE": "Education",
            "COURSE": "Education",
            "BOOK": "Education",
            "GAS STATION": "Transportation",
            "PARKING": "Transportation",
            "CAR": "Transportation",
            "AUTO": "Transportation",
            "AUTOMOBILE": "Transportation",
            "MEMBERSHIP": "Entertainment",
            "SUBSCRIPTION": "Entertainment",
            "DONATION": "Donations",
            "CHARITY": "Donations",
            "TAX": "Taxes",
            "IRS": "Taxes",
            "BILL": "Bills",
            "PAYMENT": "Bills"
          };
          
          const incomeKeywords = {
            "SALARY": "Salary & Wages",
            "WAGE": "Salary & Wages",
            "PAYROLL": "Salary & Wages",
            "INCOME": "Salary & Wages",
            "DIRECT DEPOSIT": "Salary & Wages",
            "COMMISSION": "Salary & Wages",
            "BONUS": "Salary & Wages",
            "INTEREST": "Investment Income",
            "DIVIDEND": "Investment Income",
            "INVESTMENT": "Investment Income",
            "STOCK": "Investment Income",
            "REFUND": "Refunds",
            "REIMBURSEMENT": "Refunds",
            "RETURN": "Refunds",
            "GIFT": "Gifts",
            "TRANSFER": "Transfers",
            "RENT": "Rental Income",
            "PAYMENT RECEIVED": "Other Income"
          };
          
          // Choose keyword set based on batch type
          const keywordMap = isExpenseBatch ? expenseKeywords : incomeKeywords;
          
          // Check for keyword matches in descriptions and merchants
          [...descriptions, ...merchants].forEach(text => {
            if (!text) return;
            
            Object.keys(keywordMap).forEach(keyword => {
              if (containsKeyword(text, keyword)) {
                const categoryName = keywordMap[keyword];
                categorySuggestionScores[categoryName] = (categorySuggestionScores[categoryName] || 0) + 1;
              }
            });
          });
          
          // Find matching categories from our actual category list
          const categoryMatches = [];
          Object.keys(categorySuggestionScores).forEach(categoryName => {
            // Find category by name in our actual categories list
            const matchingCategories = state.categories.filter(c => 
              c.name.toLowerCase().includes(categoryName.toLowerCase()) || 
              categoryName.toLowerCase().includes(c.name.toLowerCase())
            );
            
            matchingCategories.forEach(category => {
              // Only add categories with the right type (income/expense)
              if ((isExpenseBatch && category.type === 'expense') ||
                  (!isExpenseBatch && category.type === 'income')) {
                categoryMatches.push({
                  category,
                  score: categorySuggestionScores[categoryName]
                });
              }
            });
          });
          
          // Sort by score (highest first) and take top 3
          const sortedMatches = categoryMatches.sort((a, b) => b.score - a.score);
          return sortedMatches.slice(0, 3).map(match => match.category);
        };
        
        // Open the transaction view modal for a batch
        const viewAllTransactions = (batchId) => {
          const batch = state.enrichment.transactionBatches.find(b => b.batchId === batchId);
          if (!batch) return;
          
          // Set up the review modal
          state.reviewModal.isOpen = true;
          state.reviewModal.title = getBatchDescription(batch) || 'Transaction Review';
          state.reviewModal.batchId = batchId;
          state.reviewModal.isLoading = true;
          state.reviewModal.error = null;
          state.reviewModal.selectedIds = [];
          state.reviewModal.batchCategoryId = '';
          state.reviewModal.selectAll = false;
          
          // Load transactions from the batch
          if (batch.transactions) {
            state.reviewModal.transactions = [...batch.transactions];
            state.reviewModal.isLoading = false;
            
            // Generate suggested categories
            state.reviewModal.suggestedCategories = getSuggestedCategoriesForBatch(batch);
          } else {
            // If transactions aren't already loaded, set error
            state.reviewModal.error = 'Could not load transactions for this batch';
            state.reviewModal.isLoading = false;
          }
        };
        
        // Toggle selection of a transaction in review modal
        const toggleSelection = (transactionId) => {
          const index = state.reviewModal.selectedIds.indexOf(transactionId);
          if (index === -1) {
            state.reviewModal.selectedIds.push(transactionId);
          } else {
            state.reviewModal.selectedIds.splice(index, 1);
          }
          
          // Update selectAll status
          state.reviewModal.selectAll = 
            state.reviewModal.selectedIds.length === state.reviewModal.transactions.length;
        };
        
        // Toggle select all transactions in review modal
        const toggleSelectAllTransactions = () => {
          const selectAll = !state.reviewModal.selectAll;
          state.reviewModal.selectAll = selectAll;
          
          if (selectAll) {
            // Select all transactions
            state.reviewModal.selectedIds = state.reviewModal.transactions.map(t => t.id);
          } else {
            // Deselect all
            state.reviewModal.selectedIds = [];
          }
        };
        
        // Apply category to selected transactions in review modal
        const reviewApplyCategory = async () => {
          if (!state.reviewModal.batchCategoryId || state.reviewModal.selectedIds.length === 0) {
            return;
          }
          
          try {
            state.reviewModal.isLoading = true;
            
            // Call API to update categories
            await api.transactions.batchUpdateCategory(
              state.reviewModal.selectedIds,
              state.reviewModal.batchCategoryId
            );
            
            // Update UI
            state.reviewModal.transactions.forEach(transaction => {
              if (state.reviewModal.selectedIds.includes(transaction.id)) {
                transaction.categoryId = state.reviewModal.batchCategoryId;
              }
            });
            
            // Reset selection
            state.reviewModal.selectedIds = [];
            state.reviewModal.batchCategoryId = '';
            state.reviewModal.selectAll = false;
          } catch (error) {
            state.reviewModal.error = `Failed to update categories: ${error.message}`;
            console.error('Error applying batch category:', error);
          } finally {
            state.reviewModal.isLoading = false;
          }
        };
        
        // Quickly apply a category to all transactions in review modal
        const quickApplyCategory = async (categoryId) => {
          if (!categoryId) return;
          
          try {
            // If there are already selected transactions, apply to those
            if (state.reviewModal.selectedIds.length > 0) {
              state.reviewModal.batchCategoryId = categoryId;
              await reviewApplyCategory();
            } else {
              // Otherwise select all and apply
              state.reviewModal.selectAll = true;
              state.reviewModal.selectedIds = state.reviewModal.transactions.map(t => t.id);
              state.reviewModal.batchCategoryId = categoryId;
              await reviewApplyCategory();
            }
          } catch (error) {
            console.error('Quick apply category failed:', error);
          }
        };
        
        // Close the review modal
        const closeReviewModal = () => {
          state.reviewModal.isOpen = false;
          state.reviewModal.transactions = [];
          state.reviewModal.selectedIds = [];
        };
        
        // Finish review and return to batches
        const finishReview = () => {
          closeReviewModal();
          
          // If this was done during enrichment flow, potentially update UI
          if (state.enrichment.showModal && state.enrichment.currentStep === 'enrichment') {
            // Could update progress or batch status if needed
          }
        };
        
        // Quick categorize directly from batch list
        const quickCategorize = async (batchId, categoryId) => {
          const batch = state.enrichment.transactionBatches.find(b => b.batchId === batchId);
          if (!batch || !categoryId) return;
          
          try {
            state.loading.enrichment = true;
            
            // Get all transaction IDs from the batch
            const transactionIds = batch.transactions.map(t => t.id);
            
            // Apply category to all transactions in the batch
            await api.transactions.batchUpdateCategory(transactionIds, categoryId);
            
            // Update local transactions 
            batch.transactions.forEach(t => {
              t.categoryId = categoryId;
            });
            
            // Refresh the batches
            await fetchEnrichmentBatches(state.enrichment.currentUploadId);
            
            // Show success notification (could be added elsewhere in UI)
            console.log(`Applied category to all transactions in batch ${batch.batchId}`);
          } catch (error) {
            console.error(`Failed to quick categorize batch ${batchId}:`, error);
          } finally {
            state.loading.enrichment = false;
          }
        };
        
        // Continue to transactions tab after completion
        const continueToTransactions = () => {
          // Close the modal
          closeEnrichmentModal();
          
          // Switch to transactions tab
          activeTab.value = 'transactions';
        };
        
        // Initialize data on component mount
        onMounted(async () => {
          try {
            // Fetch initial data in parallel
            await Promise.all([
              fetchCategories(),
              fetchTransactions()
            ]);
            
            // Fetch report data after we have categories and transactions
            if (hasData.value) {
              // Fetch both dashboard and report data
              await Promise.all([
                fetchDashboardData(),
                fetchReportData()
              ]);
            } else {
              // Even with no transactions, try to fetch dashboard data
              await fetchDashboardData();
            }
            
            // Fetch settings
            await fetchSettings();
          } catch (error) {
            console.error('Error initializing app data:', error);
          }
        });
        
        // Watch for tab changes
        watch(activeTab, (newTab) => {
          if (newTab === 'reports' && hasData.value) {
            fetchReportData();
          } else if (newTab === 'home') {
            // Refresh dashboard data when returning to home tab
            fetchDashboardData();
          }
        });
        
        // Transaction management functions
        
        // Format date for display
        const formatDate = (dateString) => {
          if (!dateString) return 'N/A';
          const date = new Date(dateString);
          return new Intl.DateTimeFormat('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
          }).format(date);
        };
        
        // Get the appropriate badge class based on confidence score
        const getConfidenceBadgeClass = (confidence) => {
          if (!confidence && confidence !== 0) return 'badge-neutral';
          
          // Convert to number if it's a string
          const score = parseFloat(confidence);
          
          if (score >= 0.9) return 'badge-success';
          if (score >= 0.7) return 'badge-primary';
          if (score >= 0.5) return 'badge-warning';
          return 'badge-error';
        };
        
        // Format currency for display
        const formatCurrency = (amount) => {
          if (amount === undefined || amount === null) return '$0.00';
          return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
          }).format(amount);
        };
        
        // Get category name by ID
        const getCategoryName = (categoryId) => {
          if (!categoryId) return 'Uncategorized';
          const category = state.categories.find(c => c.id === categoryId);
          return category ? category.name : 'Uncategorized';
        };
        
        // Get category color by ID
        const getCategoryColor = (categoryId) => {
          if (!categoryId) return '#718096'; // Default gray color
          const category = state.categories.find(c => c.id === categoryId);
          return category ? category.color : '#718096';
        };
        
        // Get confidence indicator color
        const getConfidenceColor = (confidenceScore) => {
          if (confidenceScore >= 0.8) return '#36D399'; // success
          if (confidenceScore >= 0.6) return '#FBBD23'; // warning
          return '#F87272'; // error
        };
        
        // Select an alternative category
        const selectAlternativeCategory = (categoryId) => {
          if (!categoryId) return;
          
          console.log(` [CLIENT] Selected alternative category: ${categoryId}`);
          state.enrichment.suggestedCategory = categoryId;
          
          // Find the category in top categories to get confidence
          if (state.enrichment.aiSuggestions?.topCategories) {
            const altCategory = state.enrichment.aiSuggestions.topCategories.find(c => c.categoryId === categoryId);
            if (altCategory) {
              state.enrichment.suggestedCategoryConfidence = altCategory.avgConfidence;
              console.log(` [CLIENT] Updated confidence to: ${altCategory.avgConfidence}`);
            }
          }
        };
        
        // Format account type for display
        const formatAccountType = (accountType) => {
          if (!accountType) return 'Unknown';
          
          // Convert snake_case to Title Case
          const mapping = {
            'bank': 'Bank Account',
            'credit_card': 'Credit Card',
            'investment': 'Investment',
            'cash': 'Cash',
            'wallet': 'Digital Wallet',
            'other': 'Other'
          };
          
          return mapping[accountType] || accountType.charAt(0).toUpperCase() + accountType.slice(1).replace(/_/g, ' ');
        };
        
        // Filter transactions based on search query and filters
        const filterTransactions = () => {
          // Reset pagination when filter changes
          paginationStart.value = 0;
          // Close the filter dropdown
          isFilterDropdownOpen.value = false;
        };
        
        // Toggle filter dropdown
        const toggleFilterDropdown = () => {
          isFilterDropdownOpen.value = !isFilterDropdownOpen.value;
          // Add event listener to close dropdown when clicking outside
          if (isFilterDropdownOpen.value) {
            setTimeout(() => {
              document.addEventListener('click', closeFilterDropdown);
            }, 0);
          }
        };
        
        // Close filter dropdown when clicking outside
        const closeFilterDropdown = (event) => {
          if (isFilterDropdownOpen.value) {
            isFilterDropdownOpen.value = false;
            document.removeEventListener('click', closeFilterDropdown);
          }
        };
        
        // Set category filter
        const setCategoryFilter = (categoryId) => {
          categoryFilter.value = categoryId;
          filterTransactions();
        };
        
        // Open batch category modal
        const openBatchCategoryModal = () => {
          // Select all uncategorized transactions
          selectedTransactions.value = state.transactions
            .filter(tx => !tx.categoryId)
            .map(tx => tx.id);
          
          // If there are any selected transactions, show the batch action bar
          if (selectedTransactions.value.length > 0) {
            // Scroll to the transactions table
            document.querySelector('.transactions-container').scrollIntoView({ behavior: 'smooth' });
          } else {
            alert('No uncategorized transactions found.');
          }
        };
        
        // Computed property for filtered transactions
        const filteredTransactions = computed(() => {
          if (!state.transactions.length) return [];
          
          return state.transactions.filter(tx => {
            // Search query filter
            const searchMatches = !transactionSearchQuery.value || 
              tx.description?.toLowerCase().includes(transactionSearchQuery.value.toLowerCase()) ||
              tx.merchant?.toLowerCase().includes(transactionSearchQuery.value.toLowerCase());
            
            // Transaction type filter
            const typeMatches = transactionTypeFilter.value === 'all' || 
              tx.type === transactionTypeFilter.value;
            
            // Date filter
            let dateMatches = true;
            if (transactionDateFilter.value === 'thisMonth') {
              const now = new Date();
              const txDate = new Date(tx.date);
              dateMatches = txDate.getMonth() === now.getMonth() && 
                txDate.getFullYear() === now.getFullYear();
            } else if (transactionDateFilter.value === 'last3Months') {
              const now = new Date();
              const threeMonthsAgo = new Date();
              threeMonthsAgo.setMonth(now.getMonth() - 3);
              const txDate = new Date(tx.date);
              dateMatches = txDate >= threeMonthsAgo;
            }
            
            // Category filter
            let categoryMatches = true;
            if (categoryFilter.value === 'uncategorized') {
              categoryMatches = !tx.categoryId;
            } else if (categoryFilter.value !== 'all') {
              categoryMatches = tx.categoryId === categoryFilter.value;
            }
            
            return searchMatches && typeMatches && dateMatches && categoryMatches;
          });
        });
        
        // Sort transactions
        const sortTransactions = (field) => {
          if (transactionSort.field === field) {
            // If already sorting by this field, toggle direction
            transactionSort.direction = transactionSort.direction === 'asc' ? 'desc' : 'asc';
          } else {
            // Otherwise, sort by the new field in ascending order
            transactionSort.field = field;
            transactionSort.direction = 'asc';
          }
        };
        
        // Computed property for sorted and filtered transactions
        const sortedTransactions = computed(() => {
          const transactions = [...filteredTransactions.value];
          
          return transactions.sort((a, b) => {
            let comparison = 0;
            
            if (transactionSort.field === 'date') {
              comparison = new Date(a.date) - new Date(b.date);
            } else if (transactionSort.field === 'amount') {
              comparison = a.amount - b.amount;
            } else if (transactionSort.field === 'description') {
              comparison = a.description.localeCompare(b.description);
            } else if (transactionSort.field === 'account') {
              comparison = (a.account || '').localeCompare(b.account || '');
            } else if (transactionSort.field === 'accountType') {
              comparison = (a.accountType || '').localeCompare(b.accountType || '');
            } else if (transactionSort.field === 'currency') {
              comparison = (a.currency || 'USD').localeCompare(b.currency || 'USD');
            }
            
            return transactionSort.direction === 'asc' ? comparison : -comparison;
          });
        });
        
        // Computed property for paginated transactions
        const paginatedTransactions = computed(() => {
          return sortedTransactions.value.slice(
            paginationStart.value,
            paginationStart.value + paginationLimit.value
          );
        });
        
        // Computed property for current page number
        const currentPage = computed(() => {
          return Math.floor(paginationStart.value / paginationLimit.value) + 1;
        });
        
        // Toggle select all transactions
        const toggleSelectAll = () => {
          if (selectAllTransactions.value) {
            selectedTransactions.value = filteredTransactions.value.map(tx => tx.id);
          } else {
            selectedTransactions.value = [];
          }
        };
        
        // Calculate total income from transactions
        const calculateTotalIncome = (transactions) => {
          return transactions
            .filter(tx => tx.type === 'income')
            .reduce((sum, tx) => sum + (tx.amount || 0), 0);
        };
        
        // Calculate total expenses from transactions
        const calculateTotalExpenses = (transactions) => {
          return transactions
            .filter(tx => tx.type === 'expense')
            .reduce((sum, tx) => sum + Math.abs(tx.amount || 0), 0);
        };
        
        // Count transactions by type
        const calculateCountByType = (transactions, type) => {
          return transactions.filter(tx => tx.type === type).length;
        };
        
        // Set transaction type filter
        const setTransactionTypeFilter = (type) => {
          transactionTypeFilter.value = type;
          filterTransactions();
        };
        
        // Set transaction date filter
        const setTransactionDateFilter = (dateFilter) => {
          transactionDateFilter.value = dateFilter;
          filterTransactions();
        };
        
        // Handle pagination - go to previous page
        const previousPage = () => {
          if (paginationStart.value >= paginationLimit.value) {
            paginationStart.value -= paginationLimit.value;
          }
        };
        
        // Handle pagination - go to next page
        const nextPage = () => {
          if (paginationStart.value + paginationLimit.value < filteredTransactions.value.length) {
            paginationStart.value += paginationLimit.value;
          }
        };
        
        // Open modal for batch categorization
        // Category management functions
        
        // Open the category modal for creating a new category
        const openCategoryModal = (categoryId = null) => {
          // Reset the form
          categoryForm.name = '';
          categoryForm.type = 'expense';
          categoryForm.color = '#6366F1'; // Default indigo color
          categoryForm.description = '';
          
          // If editing an existing category, load its data
          if (categoryId) {
            editingCategoryId.value = categoryId;
            const category = state.categories.find(c => c.id === categoryId);
            if (category) {
              categoryForm.name = category.name;
              categoryForm.type = category.type;
              categoryForm.color = category.color;
              categoryForm.description = category.description || '';
            }
          } else {
            editingCategoryId.value = null;
          }
          
          // Open the modal
          isCategoryModalOpen.value = true;
        };
        
        // Close the category modal
        const closeCategoryModal = () => {
          isCategoryModalOpen.value = false;
        };
        
        // Save a category (create new or update existing)
        const saveCategory = async () => {
          try {
            if (editingCategoryId.value) {
              // Update existing category
              await api.categories.update(editingCategoryId.value, categoryForm);
            } else {
              // Create new category
              await api.categories.create(categoryForm);
            }
            
            // Refresh categories list
            await fetchCategories();
            
            // Close the modal
            closeCategoryModal();
          } catch (error) {
            console.error('Failed to save category:', error);
            state.errors.categories = error.message;
          }
        };
        
        // Delete a category
        const deleteCategory = async (categoryId) => {
          if (!confirm('Are you sure you want to delete this category? This will not delete transactions, but will remove the category from them.')) {
            return;
          }
          
          try {
            await api.categories.delete(categoryId);
            await fetchCategories();
          } catch (error) {
            console.error('Failed to delete category:', error);
            state.errors.categories = error.message;
          }
        };
        
        // Edit category - Open modal with existing category data
        const editCategory = (category) => {
          openCategoryModal(category.id);
        };
        
        // Transaction editing functions
        const editTransaction = (transaction) => {
          editingTransactionId.value = transaction.id;
          
          // Convert from ISO date string to YYYY-MM-DD
          const isoDate = new Date(transaction.date);
          const formattedDate = isoDate.toISOString().split('T')[0];
          
          // Map transaction data to form
          transactionForm.date = formattedDate;
          transactionForm.description = transaction.description;
          transactionForm.amount = Math.abs(transaction.amount);
          transactionForm.type = transaction.type;
          transactionForm.merchant = transaction.merchant || '';
          transactionForm.account = transaction.account || '';
          transactionForm.accountType = transaction.accountType || 'bank';
          transactionForm.currency = transaction.currency || 'USD';
          transactionForm.categoryId = transaction.categoryId || '';
          transactionForm.notes = transaction.notes || '';
          
          // Convert tags array to comma-separated string
          if (transaction.tags && Array.isArray(transaction.tags)) {
            transactionForm.tagsInput = transaction.tags.join(', ');
          } else {
            transactionForm.tagsInput = '';
          }
          
          // Open the modal
          isTransactionModalOpen.value = true;
        };
        
        const closeTransactionModal = () => {
          isTransactionModalOpen.value = false;
        };
        
        const saveTransaction = async () => {
          try {
            // Convert tags input to array
            const tags = transactionForm.tagsInput
              ? transactionForm.tagsInput.split(',').map(tag => tag.trim())
              : [];
            
            // Create transaction object from form data
            // Always use absolute value for amount - the type field determines income/expense
            const transaction = {
              date: transactionForm.date,
              description: transactionForm.description,
              amount: Math.abs(transactionForm.amount),
              type: transactionForm.type,
              merchant: transactionForm.merchant || null,
              account: transactionForm.account || null,
              accountType: transactionForm.accountType,
              currency: transactionForm.currency,
              categoryId: transactionForm.categoryId || null,
              tags: tags,
              notes: transactionForm.notes || null
            };
            
            if (editingTransactionId.value) {
              // Update existing transaction
              await api.transactions.update(editingTransactionId.value, transaction);
            } else {
              // Create new transaction
              await api.transactions.create(transaction);
            }
            
            // Refresh transactions list
            await fetchTransactions();
            
            // Close the modal
            closeTransactionModal();
          } catch (error) {
            console.error('Failed to save transaction:', error);
            state.errors.transactions = error.message;
          }
        };
        
        // Get income categories only
        const incomeCategories = computed(() => {
          return state.categories.filter(category => category.type === 'income');
        });
        
        // Get expense categories only
        const expenseCategories = computed(() => {
          return state.categories.filter(category => category.type === 'expense');
        });
        
        // Get transaction count for a category
        const getCategoryTransactionCount = (categoryId) => {
          return state.transactions.filter(tx => tx.categoryId === categoryId).length;
        };
        
        // Get total amount for a category
        const getCategoryTotal = (categoryId) => {
          return state.transactions
            .filter(tx => tx.categoryId === categoryId)
            .reduce((sum, tx) => sum + (tx.amount || 0), 0);
        };
        
        // Apply category to multiple transactions
        const applyBatchCategory = async () => {
          if (!batchCategoryId.value || selectedTransactions.value.length === 0) {
            return;
          }
          
          try {
            await api.transactions.updateCategory(selectedTransactions.value, batchCategoryId.value);
            
            // Refresh transactions to show new categories
            await fetchTransactions();
            
            // Clear selection
            selectedTransactions.value = [];
            selectAllTransactions.value = false;
            batchCategoryId.value = '';
          } catch (error) {
            console.error('Failed to update categories:', error);
            state.errors.transactions = error.message;
          }
        };
        
        // Delete a single transaction
        const deleteTransaction = async (id) => {
          if (!confirm('Are you sure you want to delete this transaction?')) {
            return;
          }
          
          try {
            await api.transactions.delete(id);
            
            // Refresh transactions after deletion
            await fetchTransactions();
          } catch (error) {
            console.error('Failed to delete transaction:', error);
            state.errors.transactions = error.message;
          }
        };
        
        // Delete multiple transactions
        const deleteBatchTransactions = async () => {
          if (selectedTransactions.value.length === 0) {
            return;
          }
          
          if (!confirm(`Are you sure you want to delete ${selectedTransactions.value.length} transaction(s)?`)) {
            return;
          }
          
          try {
            const deletePromises = selectedTransactions.value.map(id => api.transactions.delete(id));
            await Promise.all(deletePromises);
            
            // Refresh transactions after deletion
            await fetchTransactions();
            
            // Clear selection
            selectedTransactions.value = [];
            selectAllTransactions.value = false;
          } catch (error) {
            console.error('Failed to delete transactions:', error);
            state.errors.transactions = error.message;
          }
        };
        
        // Category filter helper functions
        const getIncomeCategories = (categories) => {
          return categories.filter(category => category.type === 'income');
        };
        
        const getExpenseCategories = (categories) => {
          return categories.filter(category => category.type === 'expense');
        };
        
        return {
          // State variables
          state,
          hasData,
          isUploadActive,
          uploadProgress,
          activeTab,
          selectedDateRange,
          
          // Transaction management
          transactionSearchQuery,
          selectedTransactions,
          selectAllTransactions,
          transactionTypeFilter,
          transactionDateFilter,
          categoryFilter,
          paginationStart,
          paginationLimit,
          transactionSort,
          batchCategoryId,
          batchTags,
          batchNotes,
          isFilterDropdownOpen,
          
          // Transaction modal
          isTransactionModalOpen,
          editingTransactionId,
          transactionForm,
          editTransaction,
          closeTransactionModal,
          saveTransaction,
          
          // Category management
          isCategoryModalOpen,
          editingCategoryId,
          categoryForm,
          colorPalette,
          isBatchCategoryModalOpen,
          filteredTransactions,
          sortedTransactions,
          paginatedTransactions,
          currentPage,
          
          // Transaction functions
          formatDate,
          formatCurrency,
          getCategoryName,
          getCategoryColor,
          getConfidenceBadgeClass,
          formatAccountType,
          filterTransactions,
          sortTransactions,
          toggleSelectAll,
          calculateTotalIncome,
          calculateTotalExpenses,
          calculateCountByType,
          setTransactionTypeFilter,
          setTransactionDateFilter,
          setCategoryFilter,
          toggleFilterDropdown,
          closeFilterDropdown,
          previousPage,
          nextPage,
          openCategoryModal,
          closeCategoryModal,
          saveCategory,
          deleteCategory,
          editCategory,
          incomeCategories,
          expenseCategories,
          getCategoryTransactionCount,
          getCategoryTotal,
          openBatchCategoryModal,
          applyBatchCategory,
          deleteTransaction,
          deleteBatchTransactions,
          
          // File upload and UI control
          handleFileUpload,
          handleFileDrop,
          useSampleData,
          setUploadActive,
          setDateRange,
          
          // Enrichment flow functions
          closeEnrichmentModal,
          applyEnrichmentToBatches,
          fetchEnrichmentBatches,
          enrichBatch,
          completeUpload,
          updateEnrichmentProgress,
          getIncomeCategories,
          getExpenseCategories,
          updateAccountSource,
          areAccountDetailsComplete,
          processAccountSetup,
          getBatchDescription,
          getSampleTransactions,
          forceRefreshBatches,
          getSuggestedCategoriesForBatch,
          startEnrichAllBatches,
          suggestCategoryForBatch,
          acceptSuggestedCategory,
          rejectSuggestedCategory,
          viewAllTransactions
        };
      }
    }).mount('#app');
    
    // Create Charts
    window.addEventListener('load', function() {
      setTimeout(() => {
        initCharts();
      }, 500);
    });
    
    function initCharts() {
      // Monthly Spending Bar Chart
      const monthlySpendingCtx = document.getElementById('monthlySpendingChart');
      if (monthlySpendingCtx) {
        const monthlySpendingChart = new Chart(monthlySpendingCtx, {
          type: 'bar',
          data: {
            labels: ['Housing', 'Food', 'Transportation', 'Entertainment', 'Utilities', 'Shopping', 'Healthcare', 'Personal Care', 'Education'],
            datasets: [{
              label: 'Spending Amount',
              data: [1200, 550, 350, 200, 180, 320, 150, 90, 220],
              backgroundColor: [
                'rgba(52, 211, 153, 0.8)',
                'rgba(59, 130, 246, 0.8)',
                'rgba(139, 92, 246, 0.8)',
                'rgba(249, 115, 22, 0.8)',
                'rgba(239, 68, 68, 0.8)',
                'rgba(16, 185, 129, 0.8)',
                'rgba(14, 165, 233, 0.8)',
                'rgba(168, 85, 247, 0.8)',
                'rgba(251, 146, 60, 0.8)'
              ],
              borderColor: [
                'rgba(52, 211, 153, 1)',
                'rgba(59, 130, 246, 1)',
                'rgba(139, 92, 246, 1)',
                'rgba(249, 115, 22, 1)',
                'rgba(239, 68, 68, 1)',
                'rgba(16, 185, 129, 1)',
                'rgba(14, 165, 233, 1)',
                'rgba(168, 85, 247, 1)',
                'rgba(251, 146, 60, 1)'
              ],
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: (context) => {
                    const value = context.raw;
                    return `$${value.toLocaleString()}`;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  callback: (value) => `$${value}`
                }
              }
            }
          }
        });
      }
      
      // Spending Trend Line Chart
      const trendCtx = document.getElementById('trendChart');
      if (trendCtx) {
        // Generate dates for the last 12 months
        const today = new Date();
        const dates = Array.from({ length: 12 }, (_, i) => {
          const date = new Date(today);
          date.setDate(1);
          date.setMonth(today.getMonth() - i);
          return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        }).reverse();
        
        // Random data for spending trend
        const spendingData = Array.from({ length: 12 }, () => {
          const baseAmount = 2500;
          const variance = Math.random() * 1000 - 500; // Random between -500 and 500
          return Math.round(baseAmount + variance);
        });
        
        const trendChart = new Chart(trendCtx, {
          type: 'line',
          data: {
            labels: dates,
            datasets: [{
              label: 'Spending Trend',
              data: spendingData,
              borderColor: 'rgba(124, 58, 237, 1)',
              backgroundColor: 'rgba(124, 58, 237, 0.2)',
              borderWidth: 2,
              tension: 0.3,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: (context) => {
                    const value = context.raw;
                    return `$${value.toLocaleString()}`;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  callback: (value) => `$${value}`
                }
              }
            }
          }
        });
      }
      
      // Category Doughnut Chart
      const categoryCtx = document.getElementById('categoryChart');
      if (categoryCtx) {
        const categoryChart = new Chart(categoryCtx, {
          type: 'doughnut',
          data: {
            labels: ['Housing', 'Food', 'Transportation', 'Entertainment', 'Utilities', 'Shopping'],
            datasets: [{
              label: 'Spending by Category',
              data: [1200, 550, 350, 200, 180, 320],
              backgroundColor: [
                'rgba(124, 58, 237, 0.8)',
                'rgba(52, 211, 153, 0.8)',
                'rgba(59, 130, 246, 0.8)',
                'rgba(249, 115, 22, 0.8)',
                'rgba(239, 68, 68, 0.8)',
                'rgba(16, 185, 129, 0.8)'
              ],
              borderColor: [
                'rgba(124, 58, 237, 1)',
                'rgba(52, 211, 153, 1)',
                'rgba(59, 130, 246, 1)',
                'rgba(249, 115, 22, 1)',
                'rgba(239, 68, 68, 1)',
                'rgba(16, 185, 129, 1)'
              ],
              borderWidth: 1,
              hoverOffset: 15
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '60%',
            plugins: {
              legend: {
                position: 'right',
                labels: {
                  boxWidth: 15,
                  padding: 15
                }
              },
              tooltip: {
                callbacks: {
                  label: (context) => {
                    const value = context.raw;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    return `${context.label}: $${value.toLocaleString()} (${percentage}%)`;
                  }
                }
              }
            }
          }
        });
      }
      
      // Income vs Expenses Stacked Chart
      const incomeExpensesCtx = document.getElementById('incomeExpensesChart');
      if (incomeExpensesCtx) {
        // Generate dates for the last 6 months
        const today = new Date();
        const dates = Array.from({ length: 6 }, (_, i) => {
          const date = new Date(today);
          date.setDate(1);
          date.setMonth(today.getMonth() - i);
          return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        }).reverse();
        
        // Random data for income and expenses
        const incomeData = Array.from({ length: 6 }, () => {
          return Math.round(3800 + (Math.random() * 400 - 200));
        });
        
        const expensesData = incomeData.map(income => {
          const expenseRatio = 0.7 + (Math.random() * 0.25);
          return Math.round(income * expenseRatio);
        });
        
        const incomeExpensesChart = new Chart(incomeExpensesCtx, {
          type: 'bar',
          data: {
            labels: dates,
            datasets: [
              {
                label: 'Income',
                data: incomeData,
                backgroundColor: 'rgba(52, 211, 153, 0.8)',
                borderColor: 'rgba(52, 211, 153, 1)',
                borderWidth: 1
              },
              {
                label: 'Expenses',
                data: expensesData,
                backgroundColor: 'rgba(229, 62, 62, 0.8)',
                borderColor: 'rgba(229, 62, 62, 1)',
                borderWidth: 1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'top',
              },
              tooltip: {
                callbacks: {
                  label: (context) => {
                    const value = context.raw;
                    const label = context.dataset.label;
                    return `${label}: $${value.toLocaleString()}`;
                  },
                  afterBody: (tooltipItems) => {
                    const index = tooltipItems[0].dataIndex;
                    const income = incomeData[index];
                    const expenses = expensesData[index];
                    
                    const difference = income - expenses;
                    const isSurplus = difference >= 0;
                    const label = isSurplus ? 'Savings' : 'Deficit';
                    const value = Math.abs(difference);
                    
                    return [`${label}: $${value.toLocaleString()}`];
                  }
                }
              }
            },
            scales: {
              x: {
                stacked: false,
              },
              y: {
                beginAtZero: true,
                ticks: {
                  callback: (value) => `$${value}`
                }
              }
            }
          }
        });
      }
    }
  </script>
</body>
</html>